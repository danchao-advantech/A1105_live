--- a/drivers/gpio/gpio-pca953x.c	2015-05-12 16:34:49.000000000 +0800
+++ b/drivers/gpio/gpio-pca953x.c	2016-01-05 20:06:59.483323229 +0800
@@ -21,6 +21,9 @@
 #ifdef CONFIG_OF_GPIO
 #include <linux/of_platform.h>
 #endif
+#ifdef CONFIG_ESP9010
+#include <linux/delay.h>
+#endif
 
 #define PCA953X_INPUT		0
 #define PCA953X_OUTPUT		1
@@ -43,6 +46,16 @@
 #define PCA953X_TYPE		0x1000
 #define PCA957X_TYPE		0x2000
 
+#ifdef CONFIG_ESP9010
+/*
+ * When Intel Rangeley CPU do smbus read/write failed
+ * (might be a data parity error) and return EIO, we 
+ * do a retry to handle this issue(just a workaround).
+ */
+#define ESP9010_RW_RETRY               1
+#define ESP9010_RETRY_COUNT            10
+#endif
+
 static const struct i2c_device_id pca953x_id[] = {
 	{ "pca9505", 40 | PCA953X_TYPE | PCA_INT, },
 	{ "pca9534", 8  | PCA953X_TYPE | PCA_INT, },
@@ -75,7 +88,7 @@
 #define MAX_BANK 5
 #define BANK_SZ 8
 
-#define NBANK(chip) (chip->gpio_chip.ngpio / BANK_SZ)
+#define NBANK(chip) ((chip->gpio_chip.ngpio / BANK_SZ) ? (chip->gpio_chip.ngpio / BANK_SZ) : 1)
 
 struct pca953x_chip {
 	unsigned gpio_start;
@@ -108,13 +121,27 @@
 	int ret;
 	int bank_shift = fls((chip->gpio_chip.ngpio - 1) / BANK_SZ);
 	int offset = off / BANK_SZ;
+#ifdef ESP9010_RW_RETRY
+	int cnt=0;
+#endif
 
 	ret = i2c_smbus_read_byte_data(chip->client,
 				(reg << bank_shift) + offset);
+#ifdef ESP9010_RW_RETRY
+	while (ret < 0) {
+		if (cnt >= ESP9010_RETRY_COUNT) break;
+		udelay(1000);
+		dev_warn(&chip->client->dev,
+			 "failed reading register, retry it (%d)\n", ret);
+		ret = i2c_smbus_read_byte_data(chip->client,
+					       (reg << bank_shift) + offset);
+		cnt++;
+	}
+#endif
 	*val = ret;
 
 	if (ret < 0) {
-		dev_err(&chip->client->dev, "failed reading register\n");
+		dev_err(&chip->client->dev, "failed reading register (%d)\n", ret);
 		return ret;
 	}
 
@@ -127,12 +154,27 @@
 	int ret = 0;
 	int bank_shift = fls((chip->gpio_chip.ngpio - 1) / BANK_SZ);
 	int offset = off / BANK_SZ;
+#ifdef ESP9010_RW_RETRY
+	int cnt=0;
+#endif
 
 	ret = i2c_smbus_write_byte_data(chip->client,
 					(reg << bank_shift) + offset, val);
+#ifdef ESP9010_RW_RETRY
+	while (ret < 0) {
+		if (cnt >= ESP9010_RETRY_COUNT) break;
+		udelay(1000);
+		dev_warn(&chip->client->dev,
+			 "failed writing register, retry it (%d)\n", ret);
+		ret = i2c_smbus_write_byte_data(chip->client,
+						(reg << bank_shift) + offset,
+						val);
+		cnt++;
+	}
+#endif
 
 	if (ret < 0) {
-		dev_err(&chip->client->dev, "failed writing register\n");
+		dev_err(&chip->client->dev, "failed writing register (%d)\n", ret);
 		return ret;
 	}
 
@@ -142,34 +184,96 @@
 static int pca953x_write_regs(struct pca953x_chip *chip, int reg, u8 *val)
 {
 	int ret = 0;
+#ifdef ESP9010_RW_RETRY
+	int cnt=0;
+#endif
 
-	if (chip->gpio_chip.ngpio <= 8)
+	if (chip->gpio_chip.ngpio <= 8) {
 		ret = i2c_smbus_write_byte_data(chip->client, reg, *val);
-	else if (chip->gpio_chip.ngpio >= 24) {
+#ifdef ESP9010_RW_RETRY
+		while (ret < 0) {
+			if (cnt >= ESP9010_RETRY_COUNT) break;
+			udelay(1000);
+			dev_warn(&chip->client->dev,
+				 "failed writing register, retry it (%d)\n", ret);
+			ret = i2c_smbus_write_byte_data(chip->client,
+							reg, *val);
+			cnt++;
+		}
+#endif
+	} else if (chip->gpio_chip.ngpio >= 24) {
 		int bank_shift = fls((chip->gpio_chip.ngpio - 1) / BANK_SZ);
 		ret = i2c_smbus_write_i2c_block_data(chip->client,
 					(reg << bank_shift) | REG_ADDR_AI,
 					NBANK(chip), val);
+#ifdef ESP9010_RW_RETRY
+		while (ret < 0) {
+			if (cnt >= ESP9010_RETRY_COUNT) break;
+			udelay(1000);
+			dev_warn(&chip->client->dev,
+				 "failed writing register, retry it (%d)\n", ret);
+			ret = i2c_smbus_write_i2c_block_data(chip->client,
+					(reg << bank_shift) | REG_ADDR_AI,
+					NBANK(chip), val);
+			cnt++;
+		}
+#endif
 	} else {
 		switch (chip->chip_type) {
 		case PCA953X_TYPE:
 			ret = i2c_smbus_write_word_data(chip->client,
 							reg << 1, (u16) *val);
+#ifdef ESP9010_RW_RETRY
+			while (ret < 0) {
+				if (cnt >= ESP9010_RETRY_COUNT) break;
+				udelay(1000);
+				dev_warn(&chip->client->dev,
+					 "failed writing register, retry it (%d)\n", ret);
+				ret = i2c_smbus_write_word_data(chip->client,
+								reg << 1,
+								(u16) *val);
+				cnt++;
+			}
+#endif
 			break;
 		case PCA957X_TYPE:
 			ret = i2c_smbus_write_byte_data(chip->client, reg << 1,
 							val[0]);
+#ifdef ESP9010_RW_RETRY
+			while (ret < 0) {
+				if (cnt >= ESP9010_RETRY_COUNT) break;
+				udelay(1000);
+				dev_warn(&chip->client->dev,
+					 "failed writing register, retry it (%d)\n", ret);
+				ret = i2c_smbus_write_byte_data(chip->client,
+								reg << 1,
+								val[0]);
+				cnt++;
+			}
+#endif
 			if (ret < 0)
 				break;
 			ret = i2c_smbus_write_byte_data(chip->client,
 							(reg << 1) + 1,
 							val[1]);
+#ifdef ESP9010_RW_RETRY
+			while (ret < 0) {
+				if (cnt >= ESP9010_RETRY_COUNT) break;
+				udelay(1000);
+				dev_warn(&chip->client->dev,
+					 "failed writing register, retry it (%d)\n", ret);
+				ret = i2c_smbus_write_byte_data(chip->client,
+								(reg << 1) + 1,
+								val[1]);
+				cnt++;
+			}
+#endif
 			break;
 		}
 	}
 
 	if (ret < 0) {
-		dev_err(&chip->client->dev, "failed writing register\n");
+		dev_err(&chip->client->dev, "failed writing register (%d)\n", ret);
 		return ret;
 	}
 
@@ -179,9 +283,22 @@
 static int pca953x_read_regs(struct pca953x_chip *chip, int reg, u8 *val)
 {
 	int ret;
+#ifdef ESP9010_RW_RETRY
+	int cnt=0;
+#endif
 
 	if (chip->gpio_chip.ngpio <= 8) {
 		ret = i2c_smbus_read_byte_data(chip->client, reg);
+#ifdef ESP9010_RW_RETRY
+		while (ret < 0) {
+			if (cnt >= ESP9010_RETRY_COUNT) break;
+			udelay(1000);
+			dev_warn(&chip->client->dev,
+				 "failed reading register, retry it (%d)\n", ret);
+			ret = i2c_smbus_read_byte_data(chip->client, reg);
+			cnt++;
+		}
+#endif
 		*val = ret;
 	} else if (chip->gpio_chip.ngpio >= 24) {
 		int bank_shift = fls((chip->gpio_chip.ngpio - 1) / BANK_SZ);
@@ -189,13 +306,35 @@
 		ret = i2c_smbus_read_i2c_block_data(chip->client,
 					(reg << bank_shift) | REG_ADDR_AI,
 					NBANK(chip), val);
+#ifdef ESP9010_RW_RETRY
+		while (ret < 0) {
+			if (cnt >= ESP9010_RETRY_COUNT) break;
+			udelay(1000);
+			dev_warn(&chip->client->dev,
+				 "failed reading register, retry it (%d)\n", ret);
+			ret = i2c_smbus_read_i2c_block_data(chip->client,
+					(reg << bank_shift) | REG_ADDR_AI,
+					NBANK(chip), val);
+			cnt++;
+		}
+#endif
 	} else {
 		ret = i2c_smbus_read_word_data(chip->client, reg << 1);
+#ifdef ESP9010_RW_RETRY
+		while (ret < 0) {
+			if (cnt >= ESP9010_RETRY_COUNT) break;
+			udelay(1000);
+			dev_warn(&chip->client->dev,
+				 "failed reading register, retry it (%d)\n", ret);
+			ret = i2c_smbus_read_word_data(chip->client, reg << 1);
+			cnt++;
+		}
+#endif
 		val[0] = (u16)ret & 0xFF;
 		val[1] = (u16)ret >> 8;
 	}
 	if (ret < 0) {
-		dev_err(&chip->client->dev, "failed reading register\n");
+		dev_err(&chip->client->dev, "failed reading register (%d)\n", ret);
 		return ret;
 	}
 
--- a/drivers/platform/x86/Kconfig	2015-05-12 16:34:49.000000000 +0800
+++ b/drivers/platform/x86/Kconfig	2015-12-30 19:21:18.106506633 +0800
@@ -838,4 +838,18 @@
 	  a paravirtualized device provided by QEMU; it lets a virtual machine
 	  (guest) communicate panic events to the host.
 
+config ESP9010
+	bool "ESP-9010 i2c devices"
+	depends on I2C
+	---help---
+	  This driver instantiates i2c devices such as
+	  i2c switch, gpio expander, and eeprom.
+
+config ESP9010_SB_I2C
+	tristate "ESP-9010 switch board i2c devices"
+	depends on ESP9010 && m
+	---help---
+	  This driver instantiates i2c devices on switch board such as
+	  i2c switch, gpio expander, and eeprom.
+
 endif # X86_PLATFORM_DEVICES
--- a/drivers/platform/x86/Makefile	2015-05-12 16:34:49.000000000 +0800
+++ b/drivers/platform/x86/Makefile	2016-01-05 20:05:12.467583229 +0800
@@ -56,4 +56,5 @@
 obj-$(CONFIG_INTEL_SMARTCONNECT)	+= intel-smartconnect.o
 
 obj-$(CONFIG_PVPANIC)           += pvpanic.o
+obj-$(CONFIG_ESP9010_SB_I2C)    += esp9010_sb_i2c.o
 obj-$(CONFIG_ALIENWARE_WMI)	+= alienware-wmi.o
--- a/drivers/platform/x86/esp9010_sb_i2c.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/platform/x86/esp9010_sb_i2c.c	2016-01-05 20:07:56.023039229 +0800
@@ -0,0 +1,1048 @@
+/*
+ **********************************************************************
+ *
+ * @filename  esp9010_sb_i2c.c
+ *
+ * @purpose   Driver to instantiate ESP-9010 switch board i2c devices
+ *
+ * @create    2015/12/31
+ *
+ * @author    eric lin <eric.lin@advantech.com.tw>
+ *
+ * @history   2015/12/31: init version
+ *
+ **********************************************************************
+ */
+/*
+ * $Copyright: Copyright 1983-2015 Advantech Co., Ltd.
+ * This program is the proprietary software of Advantech Corporation
+ * and/or its licensors, and may only be used, duplicated, modified
+ * or distributed pursuant to the terms and conditions of a separate,
+ * written license agreement executed between you and Advantech
+ * (an "Authorized License").  Except as set forth in an Authorized
+ * License, Advantech grants no license (express or implied), right
+ * to use, or waiver of any kind with respect to the Software, and
+ * Advantech expressly reserves all rights in and to the Software
+ * and all intellectual property rights therein.  IF YOU HAVE
+ * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
+ * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY ADVANTECH AND DISCONTINUE
+ * ALL USE OF THE SOFTWARE.  
+ *
+ * Except as expressly set forth in the Authorized License,
+ *
+ * 1.     THIS PROGRAM, INCLUDING ITS STRUCTURE, SEQUENCE AND ORGANIZATION,
+ * CONSTITUTES THE VALUABLE TRADE SECRETS OF ADVANTECH, AND YOU SHALL USE
+ * ALL REASONABLE EFFORTS TO PROTECT THE CONFIDENTIALITY THEREOF,
+ * AND TO USE THIS INFORMATION ONLY IN CONNECTION WITH YOUR USE OF
+ * ADVANTECH PRODUCTS.
+ *
+ * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
+ * PROVIDED "AS IS" AND WITH ALL FAULTS AND ADVANTECH MAKES NO PROMISES,
+ * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+ * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  ADVANTECH SPECIFICALLY
+ * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
+ * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
+ * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
+ * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
+ *
+ * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
+ * ADVANTECH OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
+ * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
+ * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
+ * TO USE THE SOFTWARE EVEN IF ADVANTECH HAS BEEN ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
+ * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
+ * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
+ * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
+ *
+ * 4.     REDISTRIBUTIONS IN BINARY FORM MUST REPRODUCE BELOW COPYRIGHT NOTICS
+ */
+/*
+ *  esp9010_sb_i2c.c - Driver to instantiate ESP-9010 switch board i2c devices.
+ *
+ *  Author : eric lin <eric.lin@advantech.com.tw>
+ *
+ *  Copyright (C) 2015-2016 Advantech, Inc.
+ *
+ *  I2C/SMBus Block Diagram:
+ *   ________________________________________________________________________________________
+ *  /  Switch Board                                                                          \
+ *                        +--------------+
+ *                i2c-0   | SPD EEPROM   |
+ *            (i2c-i801)+-|  SO-DIMM     |
+ *                      | |  (0x50)      |
+ *  +----------------+  | +--------------+
+ *  | LMP            |  | +--------------+
+ *  | Rangeley C2358 |  | | Clock Source |
+ *  |                |  +-| IDT CK420BQ  |
+ *  |       +------+ |  | |  (0x69)      |
+ *  |       | SMB0 |-|--+ +--------------+
+ *  |       +------+ |                      +------------+   +-------------+   +-------------+
+ *  |                |                      | I2C Switch |   | IO Expander |   |  SFP+ x4    |
+ *  |                |                    +-|  PCA9548   |<->|  PCA9539 x4 |<->|  EEPROM     |
+ *  |                |                    | |   (0x71)   |   |   (0x49)    |   | (0x50/0x51) |
+ *  |                |    +------------+  | +------------+   +-------------+   +-------------+
+ *  |       +------+ |    | I2C Switch |  | +------------+   +-------------+   +-------------+
+ *  |       | SMB1 |-|----|  PCA9545   |--+-| I2C Switch |   | IO Expander |   |  SFP+ x4    |
+ *  |       +------+ |    |   (0x70)   |  | |  PCA9548   |<->|  PCA9539 x4 |<->|  EEPROM     |
+ *  +----------------+    +------------+  | |   (0x72)   |   |   (0x49)    |   | (0x50/0x51) |
+ *                i2c-1                   | +------------+   +-------------+   +-------------+
+ *            (i2c-ismt)                  | +------------+   +-------------+   +-------------+
+ *                                        | | I2C Switch |   | IO Expander |   |  QSFP+ x2   |
+ *                                        +-|  PCA9548   |<->|  PCA9539 x4 |<->|  EEPROM     |
+ *                                          |   (0x73)   |   |   (0x49)    |   |  (0x50)     |
+ *                                          +------------+   +-------------+   +-------------+
+ *  \________________________________________________________________________________________/
+ *
+ */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <linux/platform_data/pca953x.h>
+#include <linux/i2c/pca954x.h>
+#include <linux/platform_data/at24.h>
+#include <linux/delay.h>
+
+#define ESP9010_I2C_CLIENT_TOT_NUM 33
+#define ESP9010_SB_GBASE 0
+#define ESP9010_SB_IBASE 0
+
+static struct i2c_client *esp9010_clients[ESP9010_I2C_CLIENT_TOT_NUM] = {NULL};
+static int client_index = 0;
+static bool gpio_add_success_sb_stage2_sfpp0 = false;
+static bool gpio_add_success_sb_stage2_sfpp1 = false;
+static bool gpio_add_success_sb_stage2_sfpp2 = false;
+static bool gpio_add_success_sb_stage2_sfpp3 = false;
+static bool gpio_add_success_sb_stage2_sfpp4 = false;
+static bool gpio_add_success_sb_stage2_sfpp5 = false;
+static bool gpio_add_success_sb_stage2_sfpp6 = false;
+static bool gpio_add_success_sb_stage2_sfpp7 = false;
+static bool gpio_add_success_sb_stage2_qsfp0 = false;
+static bool gpio_add_success_sb_stage2_qsfp1 = false;
+
+const char *i2c_adapter_names[] = {
+	"SMBus I801 adapter",
+	"SMBus iSMT adapter",
+};
+
+/* Keep this enum consistent with i2c_adapter_names */
+enum i2c_adapter_type {
+	I2C_ADAPTER_I801 = 0,
+	I2C_ADAPTER_ISMT,
+};
+
+enum esp9010_sb_switch_bus {
+	I2C_BUS_STAGE1_MUX0 = 0,
+	I2C_BUS_STAGE1_MUX1,
+	I2C_BUS_STAGE1_MUX2,
+};
+
+enum esp9010_sb_switch_stage1_mux0_bus {
+	I2C_BUS_STAGE1_MUX0_SFPP0 = 0,
+	I2C_BUS_STAGE1_MUX0_SFPP1,
+	I2C_BUS_STAGE1_MUX0_SFPP2,
+	I2C_BUS_STAGE1_MUX0_SFPP3,
+};
+
+enum esp9010_sb_switch_stage1_mux1_bus {
+	I2C_BUS_STAGE1_MUX1_SFPP4 = 0,
+	I2C_BUS_STAGE1_MUX1_SFPP5,
+	I2C_BUS_STAGE1_MUX1_SFPP6,
+	I2C_BUS_STAGE1_MUX1_SFPP7,
+};
+
+enum esp9010_sb_switch_stage1_mux2_bus {
+	I2C_BUS_STAGE1_MUX2_QSFP0 = 0,
+	I2C_BUS_STAGE1_MUX2_QSFP1,
+};
+
+static struct pca954x_platform_mode pmode_sb_pca9545_mux[] = {
+	{ .adap_id = ESP9010_SB_IBASE + 2, },
+	{ .adap_id = ESP9010_SB_IBASE + 3, },
+	{ .adap_id = ESP9010_SB_IBASE + 4, },
+};
+static struct pca954x_platform_data pdata_sb_pca9545_mux = {
+	.modes = pmode_sb_pca9545_mux,
+	.num_modes = ARRAY_SIZE(pmode_sb_pca9545_mux),
+};
+
+static struct pca954x_platform_mode pmode_sb_stage1_pca9545_mux0[] = {
+	{ .adap_id = ESP9010_SB_IBASE + 5, },
+	{ .adap_id = ESP9010_SB_IBASE + 6, },
+	{ .adap_id = ESP9010_SB_IBASE + 7, },
+	{ .adap_id = ESP9010_SB_IBASE + 8, },
+};
+static struct pca954x_platform_data pdata_sb_stage1_pca9545_mux0 = {
+	.modes = pmode_sb_stage1_pca9545_mux0,
+	.num_modes = ARRAY_SIZE(pmode_sb_stage1_pca9545_mux0),
+};
+
+static struct pca954x_platform_mode pmode_sb_stage1_pca9545_mux1[] = {
+	{ .adap_id = ESP9010_SB_IBASE + 9, },
+	{ .adap_id = ESP9010_SB_IBASE + 10, },
+	{ .adap_id = ESP9010_SB_IBASE + 11, },
+	{ .adap_id = ESP9010_SB_IBASE + 12, },
+};
+static struct pca954x_platform_data pdata_sb_stage1_pca9545_mux1 = {
+	.modes = pmode_sb_stage1_pca9545_mux1,
+	.num_modes = ARRAY_SIZE(pmode_sb_stage1_pca9545_mux1),
+};
+
+static struct pca954x_platform_mode pmode_sb_stage1_pca9545_mux2[] = {
+	{ .adap_id = ESP9010_SB_IBASE + 13, },
+	{ .adap_id = ESP9010_SB_IBASE + 14, },
+	{ .adap_id = ESP9010_SB_IBASE + 15, },
+	{ .adap_id = ESP9010_SB_IBASE + 16, },
+};
+static struct pca954x_platform_data pdata_sb_stage1_pca9545_mux2 = {
+	.modes = pmode_sb_stage1_pca9545_mux2,
+	.num_modes = ARRAY_SIZE(pmode_sb_stage1_pca9545_mux2),
+};
+
+static struct pca953x_platform_data pdata_sb_stage2_sfpp0 = {
+	.gpio_base = ESP9010_SB_GBASE,
+};
+static struct gpio gpios_sb_stage2_sfpp0[] = {
+	{ ESP9010_SB_GBASE,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_FIXED     ,
+	  "SFPP_TX_FAULT_0"   },
+	{ ESP9010_SB_GBASE + 1,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_FIXED     ,
+	  "SFPP_MOD_ABS_0"    },
+	{ ESP9010_SB_GBASE + 2,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_FIXED     ,
+	  "SFPP_RX_LOS_0"     },
+	{ ESP9010_SB_GBASE + 3,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_CHANGEABLE,
+	  "SFPP_TX_DISABLE_0" },
+};
+
+static struct pca953x_platform_data pdata_sb_stage2_sfpp1 = {
+	.gpio_base = ESP9010_SB_GBASE + 4,
+};
+static struct gpio gpios_sb_stage2_sfpp1[] = {
+	{ ESP9010_SB_GBASE + 4,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_FIXED     ,
+	  "SFPP_TX_FAULT_1"   },
+	{ ESP9010_SB_GBASE + 5,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_FIXED     ,
+	  "SFPP_MOD_ABS_1"    },
+	{ ESP9010_SB_GBASE + 6,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_FIXED     ,
+	  "SFPP_RX_LOS_1"     },
+	{ ESP9010_SB_GBASE + 7,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_CHANGEABLE,
+	  "SFPP_TX_DISABLE_1" },
+};
+
+static struct pca953x_platform_data pdata_sb_stage2_sfpp2 = {
+	.gpio_base = ESP9010_SB_GBASE + 8,
+};
+static struct gpio gpios_sb_stage2_sfpp2[] = {
+	{ ESP9010_SB_GBASE + 8,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_FIXED     ,
+	  "SFPP_TX_FAULT_2"   },
+	{ ESP9010_SB_GBASE + 9,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_FIXED     ,
+	  "SFPP_MOD_ABS_2"    },
+	{ ESP9010_SB_GBASE + 10,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_FIXED     ,
+	  "SFPP_RX_LOS_2"     },
+	{ ESP9010_SB_GBASE + 11,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_CHANGEABLE,
+	  "SFPP_TX_DISABLE_2" },
+};
+
+static struct pca953x_platform_data pdata_sb_stage2_sfpp3 = {
+	.gpio_base = ESP9010_SB_GBASE + 12,
+};
+static struct gpio gpios_sb_stage2_sfpp3[] = {
+	{ ESP9010_SB_GBASE + 12,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_FIXED     ,
+	  "SFPP_TX_FAULT_3"   },
+	{ ESP9010_SB_GBASE + 13,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_FIXED     ,
+	  "SFPP_MOD_ABS_3"    },
+	{ ESP9010_SB_GBASE + 14,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_FIXED     ,
+	  "SFPP_RX_LOS_3"     },
+	{ ESP9010_SB_GBASE + 15,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_CHANGEABLE,
+	  "SFPP_TX_DISABLE_3" },
+};
+
+static struct pca953x_platform_data pdata_sb_stage2_sfpp4 = {
+	.gpio_base = ESP9010_SB_GBASE + 16,
+};
+static struct gpio gpios_sb_stage2_sfpp4[] = {
+	{ ESP9010_SB_GBASE + 16,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_FIXED     ,
+	  "SFPP_TX_FAULT_4"   },
+	{ ESP9010_SB_GBASE + 17,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_FIXED     ,
+	  "SFPP_MOD_ABS_4"    },
+	{ ESP9010_SB_GBASE + 18,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_FIXED     ,
+	  "SFPP_RX_LOS_4"     },
+	{ ESP9010_SB_GBASE + 19,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_CHANGEABLE,
+	  "SFPP_TX_DISABLE_4" },
+};
+
+static struct pca953x_platform_data pdata_sb_stage2_sfpp5 = {
+	.gpio_base = ESP9010_SB_GBASE + 20,
+};
+static struct gpio gpios_sb_stage2_sfpp5[] = {
+	{ ESP9010_SB_GBASE + 20,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_FIXED     ,
+	  "SFPP_TX_FAULT_5"   },
+	{ ESP9010_SB_GBASE + 21,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_FIXED     ,
+	  "SFPP_MOD_ABS_5"    },
+	{ ESP9010_SB_GBASE + 22,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_FIXED     ,
+	  "SFPP_RX_LOS_5"     },
+	{ ESP9010_SB_GBASE + 23,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_CHANGEABLE,
+	  "SFPP_TX_DISABLE_5" },
+};
+
+static struct pca953x_platform_data pdata_sb_stage2_sfpp6 = {
+	.gpio_base = ESP9010_SB_GBASE + 24,
+};
+static struct gpio gpios_sb_stage2_sfpp6[] = {
+	{ ESP9010_SB_GBASE + 24,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_FIXED     ,
+	  "SFPP_TX_FAULT_6"   },
+	{ ESP9010_SB_GBASE + 25,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_FIXED     ,
+	  "SFPP_MOD_ABS_6"    },
+	{ ESP9010_SB_GBASE + 26,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_FIXED     ,
+	  "SFPP_RX_LOS_6"     },
+	{ ESP9010_SB_GBASE + 27,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_CHANGEABLE,
+	  "SFPP_TX_DISABLE_6" },
+};
+
+static struct pca953x_platform_data pdata_sb_stage2_sfpp7 = {
+	.gpio_base = ESP9010_SB_GBASE + 28,
+};
+static struct gpio gpios_sb_stage2_sfpp7[] = {
+	{ ESP9010_SB_GBASE + 28,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_FIXED     ,
+	  "SFPP_TX_FAULT_7"   },
+	{ ESP9010_SB_GBASE + 29,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_FIXED     ,
+	  "SFPP_MOD_ABS_7"    },
+	{ ESP9010_SB_GBASE + 30,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_FIXED     ,
+	  "SFPP_RX_LOS_7"     },
+	{ ESP9010_SB_GBASE + 31,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_CHANGEABLE,
+	  "SFPP_TX_DISABLE_7" },
+};
+
+static struct pca953x_platform_data pdata_sb_stage2_qsfp0 = {
+	.gpio_base = ESP9010_SB_GBASE + 32,
+};
+static struct gpio gpios_sb_stage2_qsfp0[] = {
+	{ ESP9010_SB_GBASE + 32,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_CHANGEABLE,
+	  "QSFP_0_RESET"      },
+	{ ESP9010_SB_GBASE + 33,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_CHANGEABLE,
+	  "QSFP_0_MODSEL"     },
+	//{ ESP9010_SB_GBASE + 34,
+	//  GPIOF_IN | GPIOF_EXPORT_DIR_CHANGEABLE,
+	//  "QSFP_0_LPMODE"     },
+	{ ESP9010_SB_GBASE + 35,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_FIXED     ,
+	  "QSFP_0_MODPRS"     },
+};
+
+static struct pca953x_platform_data pdata_sb_stage2_qsfp1 = {
+	.gpio_base = ESP9010_SB_GBASE + 36,
+};
+static struct gpio gpios_sb_stage2_qsfp1[] = {
+	{ ESP9010_SB_GBASE + 36,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_CHANGEABLE,
+	  "QSFP_1_RESET"      },
+	{ ESP9010_SB_GBASE + 37,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_CHANGEABLE,
+	  "QSFP_1_MODSEL"     },
+	//{ ESP9010_SB_GBASE + 38,
+	//  GPIOF_IN | GPIOF_EXPORT_DIR_CHANGEABLE,
+	//  "QSFP_1_LPMODE"     },
+	{ ESP9010_SB_GBASE + 39,
+	  GPIOF_IN | GPIOF_EXPORT_DIR_FIXED     ,
+	  "QSFP_1_MODPRS"     },
+};
+
+static struct at24_platform_data pdata_sb_stage2_eeprom_a0 = {
+	.byte_len = 256,
+	.page_size = 1,
+	.flags = AT24_FLAG_READONLY | AT24_FLAG_IRUGO,
+};
+static struct at24_platform_data pdata_sb_stage2_eeprom_a2 = {
+	.byte_len = 256,
+	.page_size = 1,
+	.flags = AT24_FLAG_READONLY | AT24_FLAG_IRUGO,
+};
+
+static int __init __find_i2c_adap(struct device *dev, void *data)
+{
+	const char *name = data;
+	static const char *prefix = "i2c-";
+	struct i2c_adapter *adapter;
+
+	if (strncmp(dev_name(dev), prefix, strlen(prefix)) != 0)
+	{
+		return 0;
+	}
+	adapter = to_i2c_adapter(dev);
+
+	return (strncmp(adapter->name, name, strlen(name)) == 0);
+}
+
+static int __init find_i2c_adapter_num(enum i2c_adapter_type type)
+{
+	struct device *dev = NULL;
+	struct i2c_adapter *adapter;
+	const char *name = i2c_adapter_names[type];
+
+	/* find the adapter by name */
+	dev = bus_find_device(&i2c_bus_type, NULL, (void *)name,
+			      __find_i2c_adap);
+	if (!dev) {
+		pr_err("%s: i2c adapter %s not found on system.\n",
+		       __func__, name);
+		return -ENODEV;
+	}
+	adapter = to_i2c_adapter(dev);
+
+	return adapter->nr;
+}
+
+static int __init find_i2c_mux_adapter_num(int parent_num, int num)
+{
+	struct device *dev = NULL;
+	struct i2c_adapter *adapter;
+	char name[48];
+
+	snprintf(name, sizeof(name), "i2c-%d-mux (chan_id %d)",
+		 parent_num, num);
+	/* find the adapter by name */
+	dev = bus_find_device(&i2c_bus_type, NULL, (void *)name,
+			      __find_i2c_adap);
+	if (!dev) {
+		pr_err("%s: i2c adapter %s not found on system.\n",
+		       __func__, name);
+		return -ENODEV;
+	}
+	adapter = to_i2c_adapter(dev);
+
+	return adapter->nr;
+}
+
+static __init struct i2c_client *esp9010_sb_setup_spd(
+		struct i2c_adapter *adap)
+{
+	struct i2c_board_info info_spd = {
+		I2C_BOARD_INFO("spd", 0x50),
+	};
+
+	return i2c_new_device(adap, &info_spd);
+}
+
+static __init struct i2c_client *esp9010_sb_setup_switch(struct i2c_adapter *adap)
+{
+	struct i2c_board_info info = {
+		I2C_BOARD_INFO("pca9545", 0x70),
+		.platform_data = &pdata_sb_pca9545_mux,
+	};
+
+	return i2c_new_device(adap, &info);
+}
+
+static __init struct i2c_client *esp9010_sb_setup_stage1_mux0(struct i2c_adapter *adap)
+{
+	struct i2c_board_info info = {
+		I2C_BOARD_INFO("pca9545", 0x71),
+		.platform_data = &pdata_sb_stage1_pca9545_mux0,
+	};
+
+	return i2c_new_device(adap, &info);
+}
+
+static __init struct i2c_client *esp9010_sb_setup_stage1_mux1(struct i2c_adapter *adap)
+{
+	struct i2c_board_info info = {
+		I2C_BOARD_INFO("pca9545", 0x72),
+		.platform_data = &pdata_sb_stage1_pca9545_mux1,
+	};
+
+	return i2c_new_device(adap, &info);
+}
+
+static __init struct i2c_client *esp9010_sb_setup_stage1_mux2(struct i2c_adapter *adap)
+{
+	struct i2c_board_info info = {
+		I2C_BOARD_INFO("pca9545", 0x73),
+		.platform_data = &pdata_sb_stage1_pca9545_mux2,
+	};
+
+	return i2c_new_device(adap, &info);
+}
+
+static __init struct i2c_client *esp9010_sb_setup_stage2_sfpp0(struct i2c_adapter *adap)
+{
+	int err;
+	struct i2c_client *client;
+	struct i2c_board_info info = {
+		I2C_BOARD_INFO("pca9537", 0x49),
+		.platform_data = &pdata_sb_stage2_sfpp0,
+	};
+	
+	client = i2c_new_device(adap, &info);
+	if (client) {
+		err = gpio_request_array(gpios_sb_stage2_sfpp0, ARRAY_SIZE(gpios_sb_stage2_sfpp0));
+		if (err)
+			pr_err("%s: Couldn't request gpio pins\n", __func__);
+		else
+			gpio_add_success_sb_stage2_sfpp0 = true;
+	}
+
+	return client;
+}
+
+static __init struct i2c_client *esp9010_sb_setup_stage2_sfpp1(struct i2c_adapter *adap)
+{
+	int err;
+	struct i2c_client *client;
+	struct i2c_board_info info = {
+		I2C_BOARD_INFO("pca9537", 0x49),
+		.platform_data = &pdata_sb_stage2_sfpp1,
+	};
+	
+	client = i2c_new_device(adap, &info);
+	if (client) {
+		err = gpio_request_array(gpios_sb_stage2_sfpp1, ARRAY_SIZE(gpios_sb_stage2_sfpp1));
+		if (err)
+			pr_err("%s: Couldn't request gpio pins\n", __func__);
+		else
+			gpio_add_success_sb_stage2_sfpp1 = true;
+	}
+
+	return client;
+}
+
+static __init struct i2c_client *esp9010_sb_setup_stage2_sfpp2(struct i2c_adapter *adap)
+{
+	int err;
+	struct i2c_client *client;
+	struct i2c_board_info info = {
+		I2C_BOARD_INFO("pca9537", 0x49),
+		.platform_data = &pdata_sb_stage2_sfpp2,
+	};
+	
+	client = i2c_new_device(adap, &info);
+	if (client) {
+		err = gpio_request_array(gpios_sb_stage2_sfpp2, ARRAY_SIZE(gpios_sb_stage2_sfpp2));
+		if (err)
+			pr_err("%s: Couldn't request gpio pins\n", __func__);
+		else
+			gpio_add_success_sb_stage2_sfpp2 = true;
+	}
+
+	return client;
+}
+
+static __init struct i2c_client *esp9010_sb_setup_stage2_sfpp3(struct i2c_adapter *adap)
+{
+	int err;
+	struct i2c_client *client;
+	struct i2c_board_info info = {
+		I2C_BOARD_INFO("pca9537", 0x49),
+		.platform_data = &pdata_sb_stage2_sfpp3,
+	};
+	
+	client = i2c_new_device(adap, &info);
+	if (client) {
+		err = gpio_request_array(gpios_sb_stage2_sfpp3, ARRAY_SIZE(gpios_sb_stage2_sfpp3));
+		if (err)
+			pr_err("%s: Couldn't request gpio pins\n", __func__);
+		else
+			gpio_add_success_sb_stage2_sfpp3 = true;
+	}
+
+	return client;
+}
+
+static __init struct i2c_client *esp9010_sb_setup_stage2_sfpp4(struct i2c_adapter *adap)
+{
+	int err;
+	struct i2c_client *client;
+	struct i2c_board_info info = {
+		I2C_BOARD_INFO("pca9537", 0x49),
+		.platform_data = &pdata_sb_stage2_sfpp4,
+	};
+	
+	client = i2c_new_device(adap, &info);
+	if (client) {
+		err = gpio_request_array(gpios_sb_stage2_sfpp4, ARRAY_SIZE(gpios_sb_stage2_sfpp4));
+		if (err)
+			pr_err("%s: Couldn't request gpio pins\n", __func__);
+		else
+			gpio_add_success_sb_stage2_sfpp4 = true;
+	}
+
+	return client;
+}
+
+static __init struct i2c_client *esp9010_sb_setup_stage2_sfpp5(struct i2c_adapter *adap)
+{
+	int err;
+	struct i2c_client *client;
+	struct i2c_board_info info = {
+		I2C_BOARD_INFO("pca9537", 0x49),
+		.platform_data = &pdata_sb_stage2_sfpp5,
+	};
+	
+	client = i2c_new_device(adap, &info);
+	if (client) {
+		err = gpio_request_array(gpios_sb_stage2_sfpp5, ARRAY_SIZE(gpios_sb_stage2_sfpp5));
+		if (err)
+			pr_err("%s: Couldn't request gpio pins\n", __func__);
+		else
+			gpio_add_success_sb_stage2_sfpp5 = true;
+	}
+
+	return client;
+}
+
+static __init struct i2c_client *esp9010_sb_setup_stage2_sfpp6(struct i2c_adapter *adap)
+{
+	int err;
+	struct i2c_client *client;
+	struct i2c_board_info info = {
+		I2C_BOARD_INFO("pca9537", 0x49),
+		.platform_data = &pdata_sb_stage2_sfpp6,
+	};
+	
+	client = i2c_new_device(adap, &info);
+	if (client) {
+		err = gpio_request_array(gpios_sb_stage2_sfpp6, ARRAY_SIZE(gpios_sb_stage2_sfpp6));
+		if (err)
+			pr_err("%s: Couldn't request gpio pins\n", __func__);
+		else
+			gpio_add_success_sb_stage2_sfpp6 = true;
+	}
+
+	return client;
+}
+
+static __init struct i2c_client *esp9010_sb_setup_stage2_sfpp7(struct i2c_adapter *adap)
+{
+	int err;
+	struct i2c_client *client;
+	struct i2c_board_info info = {
+		I2C_BOARD_INFO("pca9537", 0x49),
+		.platform_data = &pdata_sb_stage2_sfpp7,
+	};
+	
+	client = i2c_new_device(adap, &info);
+	if (client) {
+		err = gpio_request_array(gpios_sb_stage2_sfpp7, ARRAY_SIZE(gpios_sb_stage2_sfpp7));
+		if (err)
+			pr_err("%s: Couldn't request gpio pins\n", __func__);
+		else
+			gpio_add_success_sb_stage2_sfpp7 = true;
+	}
+
+	return client;
+}
+
+static __init struct i2c_client *esp9010_sb_setup_stage2_qsfp0(struct i2c_adapter *adap)
+{
+	int err;
+	struct i2c_client *client;
+	struct i2c_board_info info = {
+		I2C_BOARD_INFO("pca9537", 0x49),
+		.platform_data = &pdata_sb_stage2_qsfp0,
+	};
+	
+	client = i2c_new_device(adap, &info);
+	if (client) {
+		err = gpio_request_array(gpios_sb_stage2_qsfp0, ARRAY_SIZE(gpios_sb_stage2_qsfp0));
+		if (err)
+			pr_err("%s: Couldn't request gpio pins\n", __func__);
+		else
+			gpio_add_success_sb_stage2_qsfp0 = true;
+	}
+
+	return client;
+}
+
+static __init struct i2c_client *esp9010_sb_setup_stage2_qsfp1(struct i2c_adapter *adap)
+{
+	int err;
+	struct i2c_client *client;
+	struct i2c_board_info info = {
+		I2C_BOARD_INFO("pca9537", 0x49),
+		.platform_data = &pdata_sb_stage2_qsfp1,
+	};
+	
+	client = i2c_new_device(adap, &info);
+	if (client) {
+		err = gpio_request_array(gpios_sb_stage2_qsfp1, ARRAY_SIZE(gpios_sb_stage2_qsfp1));
+		if (err)
+			pr_err("%s: Couldn't request gpio pins\n", __func__);
+		else
+			gpio_add_success_sb_stage2_qsfp1 = true;
+	}
+
+	return client;
+}
+
+static __init struct i2c_client *esp9010_sb_setup_stage2_eeprom_a0(struct i2c_adapter *adap)
+{
+	struct i2c_board_info info = {
+		I2C_BOARD_INFO("24c02", 0x50),
+		.platform_data = &pdata_sb_stage2_eeprom_a0,
+	};
+
+	return i2c_new_device(adap, &info);
+}
+
+static __init struct i2c_client *esp9010_sb_setup_stage2_eeprom_a2(struct i2c_adapter *adap)
+{
+	struct i2c_board_info info = {
+		I2C_BOARD_INFO("24c02", 0x51),
+		.platform_data = &pdata_sb_stage2_eeprom_a2,
+	};
+
+	return i2c_new_device(adap, &info);
+}
+
+static int __init esp9010_sb_setup_devices_i801(void)
+{
+	struct i2c_adapter *adap;
+	int adap_num = find_i2c_adapter_num(I2C_ADAPTER_I801);
+
+	if (adap_num < 0)
+		return adap_num;
+
+	adap = i2c_get_adapter(adap_num);
+	if (!adap) {
+		pr_err("%s failed to get i2c adap %d.\n", __func__, adap_num);
+		goto exit;
+	}
+
+	esp9010_clients[client_index++] = esp9010_sb_setup_spd(adap);
+
+exit:
+	return 0;
+}
+
+static int __init esp9010_sb_setup_devices_ismt(void)
+{
+	struct i2c_adapter *adap;
+	int adap_num = find_i2c_adapter_num(I2C_ADAPTER_ISMT);
+
+	if (adap_num < 0)
+		return adap_num;
+
+	adap = i2c_get_adapter(adap_num);
+	if (!adap) {
+		pr_err("%s failed to get i2c adap %d.\n", __func__, adap_num);
+		goto exit;
+	}
+
+	esp9010_clients[client_index++] = esp9010_sb_setup_switch(adap);
+
+exit:
+	return 0;
+}
+
+static int __init esp9010_sb_setup_devices_stage1(void)
+{
+	struct i2c_adapter *adap;
+	int adap_num;
+	int parent_num;
+	
+	parent_num = find_i2c_adapter_num(I2C_ADAPTER_ISMT);
+	if (parent_num < 0)
+		return parent_num;
+
+	adap_num = find_i2c_mux_adapter_num(parent_num, I2C_BUS_STAGE1_MUX0);
+	if (adap_num < 0)
+		return adap_num;
+
+	adap = i2c_get_adapter(adap_num);
+	if (!adap) {
+		pr_err("%s failed to get i2c adap %d.\n", __func__, adap_num);
+		goto exit;
+	}
+
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage1_mux0(adap);
+
+	adap_num = find_i2c_mux_adapter_num(parent_num, I2C_BUS_STAGE1_MUX1);
+	if (adap_num < 0)
+		return adap_num;
+
+	adap = i2c_get_adapter(adap_num);
+	if (!adap) {
+		pr_err("%s failed to get i2c adap %d.\n", __func__, adap_num);
+		goto exit;
+	}
+	 
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage1_mux1(adap);
+
+	adap_num = find_i2c_mux_adapter_num(parent_num, I2C_BUS_STAGE1_MUX2);
+	if (adap_num < 0)
+		return adap_num;
+
+	adap = i2c_get_adapter(adap_num);
+	if (!adap) {
+		pr_err("%s failed to get i2c adap %d.\n", __func__, adap_num);
+		goto exit;
+	}
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage1_mux2(adap);
+
+exit:
+	return 0;
+}
+
+static int __init esp9010_sb_setup_devices_stage2(void)
+{
+	struct i2c_adapter *adap;
+	int adap_num;
+
+	adap_num = find_i2c_mux_adapter_num(I2C_BUS_STAGE1_MUX0 + 2, I2C_BUS_STAGE1_MUX0_SFPP0);
+	if (adap_num < 0)
+		return adap_num;
+
+	adap = i2c_get_adapter(adap_num);
+	if (!adap) {
+		pr_err("%s failed to get i2c adap %d.\n", __func__, adap_num);
+		goto exit;
+	}
+
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_sfpp0(adap);
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_eeprom_a0(adap);
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_eeprom_a2(adap);
+
+	adap_num = find_i2c_mux_adapter_num(I2C_BUS_STAGE1_MUX0 + 2, I2C_BUS_STAGE1_MUX0_SFPP1);
+	if (adap_num < 0)
+		return adap_num;
+
+	adap = i2c_get_adapter(adap_num);
+	if (!adap) {
+		pr_err("%s failed to get i2c adap %d.\n", __func__, adap_num);
+		goto exit;
+	}
+
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_sfpp1(adap);
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_eeprom_a0(adap);
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_eeprom_a2(adap);
+
+	adap_num = find_i2c_mux_adapter_num(I2C_BUS_STAGE1_MUX0 + 2, I2C_BUS_STAGE1_MUX0_SFPP2);
+	if (adap_num < 0)
+		return adap_num;
+
+	adap = i2c_get_adapter(adap_num);
+	if (!adap) {
+		pr_err("%s failed to get i2c adap %d.\n", __func__, adap_num);
+		goto exit;
+	}
+
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_sfpp2(adap);
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_eeprom_a0(adap);
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_eeprom_a2(adap);
+
+	adap_num = find_i2c_mux_adapter_num(I2C_BUS_STAGE1_MUX0 + 2, I2C_BUS_STAGE1_MUX0_SFPP3);
+	if (adap_num < 0)
+		return adap_num;
+
+	adap = i2c_get_adapter(adap_num);
+	if (!adap) {
+		pr_err("%s failed to get i2c adap %d.\n", __func__, adap_num);
+		goto exit;
+	}
+
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_sfpp3(adap);
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_eeprom_a0(adap);
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_eeprom_a2(adap);
+
+	adap_num = find_i2c_mux_adapter_num(I2C_BUS_STAGE1_MUX1 + 2, I2C_BUS_STAGE1_MUX1_SFPP4);
+	if (adap_num < 0)
+		return adap_num;
+
+	adap = i2c_get_adapter(adap_num);
+	if (!adap) {
+		pr_err("%s failed to get i2c adap %d.\n", __func__, adap_num);
+		goto exit;
+	}
+
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_sfpp4(adap);
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_eeprom_a0(adap);
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_eeprom_a2(adap);
+
+	adap_num = find_i2c_mux_adapter_num(I2C_BUS_STAGE1_MUX1 + 2, I2C_BUS_STAGE1_MUX1_SFPP5);
+	if (adap_num < 0)
+		return adap_num;
+
+	adap = i2c_get_adapter(adap_num);
+	if (!adap) {
+		pr_err("%s failed to get i2c adap %d.\n", __func__, adap_num);
+		goto exit;
+	}
+
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_sfpp5(adap);
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_eeprom_a0(adap);
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_eeprom_a2(adap);
+
+	adap_num = find_i2c_mux_adapter_num(I2C_BUS_STAGE1_MUX1 + 2, I2C_BUS_STAGE1_MUX1_SFPP6);
+	if (adap_num < 0)
+		return adap_num;
+
+	adap = i2c_get_adapter(adap_num);
+	if (!adap) {
+		pr_err("%s failed to get i2c adap %d.\n", __func__, adap_num);
+		goto exit;
+	}
+
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_sfpp6(adap);
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_eeprom_a0(adap);
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_eeprom_a2(adap);
+
+	adap_num = find_i2c_mux_adapter_num(I2C_BUS_STAGE1_MUX1 + 2, I2C_BUS_STAGE1_MUX1_SFPP7);
+	if (adap_num < 0)
+		return adap_num;
+
+	adap = i2c_get_adapter(adap_num);
+	if (!adap) {
+		pr_err("%s failed to get i2c adap %d.\n", __func__, adap_num);
+		goto exit;
+	}
+
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_sfpp7(adap);
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_eeprom_a0(adap);
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_eeprom_a2(adap);
+
+	adap_num = find_i2c_mux_adapter_num(I2C_BUS_STAGE1_MUX2 + 2, I2C_BUS_STAGE1_MUX2_QSFP0);
+	if (adap_num < 0)
+		return adap_num;
+
+	adap = i2c_get_adapter(adap_num);
+	if (!adap) {
+		pr_err("%s failed to get i2c adap %d.\n", __func__, adap_num);
+		goto exit;
+	}
+
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_qsfp0(adap);
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_eeprom_a0(adap);
+
+	adap_num = find_i2c_mux_adapter_num(I2C_BUS_STAGE1_MUX2 + 2, I2C_BUS_STAGE1_MUX2_QSFP1);
+	if (adap_num < 0)
+		return adap_num;
+
+	adap = i2c_get_adapter(adap_num);
+	if (!adap) {
+		pr_err("%s failed to get i2c adap %d.\n", __func__, adap_num);
+		goto exit;
+	}
+
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_qsfp1(adap);
+	esp9010_clients[client_index++] = esp9010_sb_setup_stage2_eeprom_a0(adap);
+
+exit:
+	return 0;
+}
+
+static int __init esp9010_sb_i2c_init(void)
+{
+	esp9010_sb_setup_devices_i801();
+	esp9010_sb_setup_devices_ismt();
+	mdelay(200);
+	esp9010_sb_setup_devices_stage1();
+	mdelay(200);
+	esp9010_sb_setup_devices_stage2();
+
+	return 0;
+}
+
+static void __exit esp9010_sb_i2c_exit(void)
+{
+	int i;
+
+	if (gpio_add_success_sb_stage2_sfpp0 == true) {
+		gpio_free_array(gpios_sb_stage2_sfpp0,
+						ARRAY_SIZE(gpios_sb_stage2_sfpp0));
+		gpio_add_success_sb_stage2_sfpp0 = false;
+	}
+	if (gpio_add_success_sb_stage2_sfpp1 == true) {
+		gpio_free_array(gpios_sb_stage2_sfpp1,
+						ARRAY_SIZE(gpios_sb_stage2_sfpp1));
+		gpio_add_success_sb_stage2_sfpp1 = false;
+	}
+	if (gpio_add_success_sb_stage2_sfpp2 == true) {
+		gpio_free_array(gpios_sb_stage2_sfpp2,
+						ARRAY_SIZE(gpios_sb_stage2_sfpp2));
+		gpio_add_success_sb_stage2_sfpp2 = false;
+	}
+	if (gpio_add_success_sb_stage2_sfpp3 == true) {
+		gpio_free_array(gpios_sb_stage2_sfpp3,
+						ARRAY_SIZE(gpios_sb_stage2_sfpp3));
+		gpio_add_success_sb_stage2_sfpp3 = false;
+	}
+	if (gpio_add_success_sb_stage2_sfpp4 == true) {
+		gpio_free_array(gpios_sb_stage2_sfpp4,
+						ARRAY_SIZE(gpios_sb_stage2_sfpp4));
+		gpio_add_success_sb_stage2_sfpp4 = false;
+	}
+	if (gpio_add_success_sb_stage2_sfpp5 == true) {
+		gpio_free_array(gpios_sb_stage2_sfpp5,
+						ARRAY_SIZE(gpios_sb_stage2_sfpp5));
+		gpio_add_success_sb_stage2_sfpp5 = false;
+	}
+	if (gpio_add_success_sb_stage2_sfpp6 == true) {
+		gpio_free_array(gpios_sb_stage2_sfpp6,
+						ARRAY_SIZE(gpios_sb_stage2_sfpp6));
+		gpio_add_success_sb_stage2_sfpp6 = false;
+	}
+	if (gpio_add_success_sb_stage2_sfpp7 == true) {
+		gpio_free_array(gpios_sb_stage2_sfpp7,
+						ARRAY_SIZE(gpios_sb_stage2_sfpp7));
+		gpio_add_success_sb_stage2_sfpp7 = false;
+	}
+	if (gpio_add_success_sb_stage2_qsfp0 == true) {
+		gpio_free_array(gpios_sb_stage2_qsfp0,
+						ARRAY_SIZE(gpios_sb_stage2_qsfp0));
+		gpio_add_success_sb_stage2_qsfp0 = false;
+	}
+	if (gpio_add_success_sb_stage2_qsfp1 == true) {
+		gpio_free_array(gpios_sb_stage2_qsfp1,
+						ARRAY_SIZE(gpios_sb_stage2_qsfp1));
+		gpio_add_success_sb_stage2_qsfp1 = false;
+	}
+
+	for (i=(client_index-1); i>=0; i--) {
+		if (esp9010_clients[i]) {
+			i2c_unregister_device(esp9010_clients[i]);
+			esp9010_clients[i] = NULL;
+		}
+	}
+
+	client_index = 0;
+}
+
+module_init(esp9010_sb_i2c_init);
+module_exit(esp9010_sb_i2c_exit);
+
+MODULE_DESCRIPTION("ESP-9010 Switch Board I2c driver");
+MODULE_AUTHOR("eric lin <eric.lin@advantech.com.tw>");
+MODULE_LICENSE("GPL");
