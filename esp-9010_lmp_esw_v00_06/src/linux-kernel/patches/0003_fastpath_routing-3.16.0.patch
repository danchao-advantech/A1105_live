diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/include/linux/inetdevice.h linux-source-3.16.0.patch/include/linux/inetdevice.h
--- linux-source-3.16.0/include/linux/inetdevice.h	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/include/linux/inetdevice.h	2016-08-12 03:52:38.930110025 -0400
@@ -16,6 +16,9 @@ struct ipv4_devconf {
 	void	*sysctl;
 	int	data[IPV4_DEVCONF_MAX];
 	DECLARE_BITMAP(state, IPV4_DEVCONF_MAX);
+#ifdef CONFIG_INET_LVL7_FP_UNREACHABLE_CTL
+        int     ip_unreachables;
+#endif
 };
 
 #define MC_HASH_SZ_LOG 9
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/include/linux/ipv6.h linux-source-3.16.0.patch/include/linux/ipv6.h
--- linux-source-3.16.0/include/linux/ipv6.h	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/include/linux/ipv6.h	2016-08-12 03:53:52.321865827 -0400
@@ -51,6 +51,13 @@ struct ipv6_devconf {
 	__s32           ndisc_notify;
 	__s32		suppress_frag_ndisc;
 	void		*sysctl;
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        __s32           ipv6_admin_enable;
+        __s32           ipv6_redirects;
+#endif
+#ifdef CONFIG_INET_LVL7_FP_UNREACHABLE_CTL
+        __s32            ipv6_unreachables;
+#endif
 };
 
 struct ipv6_params {
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/include/linux/ipv6.h.org linux-source-3.16.0.patch/include/linux/ipv6.h.org
--- linux-source-3.16.0/include/linux/ipv6.h.org	1969-12-31 19:00:00.000000000 -0500
+++ linux-source-3.16.0.patch/include/linux/ipv6.h.org	2016-08-12 03:08:20.130766955 -0400
@@ -0,0 +1,345 @@
+#ifndef _IPV6_H
+#define _IPV6_H
+
+#include <uapi/linux/ipv6.h>
+
+#define ipv6_optlen(p)  (((p)->hdrlen+1) << 3)
+#define ipv6_authlen(p) (((p)->hdrlen+2) << 2)
+/*
+ * This structure contains configuration options per IPv6 link.
+ */
+struct ipv6_devconf {
+	__s32		forwarding;
+	__s32		hop_limit;
+	__s32		mtu6;
+	__s32		accept_ra;
+	__s32		accept_redirects;
+	__s32		autoconf;
+	__s32		dad_transmits;
+	__s32		rtr_solicits;
+	__s32		rtr_solicit_interval;
+	__s32		rtr_solicit_delay;
+	__s32		force_mld_version;
+	__s32		mldv1_unsolicited_report_interval;
+	__s32		mldv2_unsolicited_report_interval;
+	__s32		use_tempaddr;
+	__s32		temp_valid_lft;
+	__s32		temp_prefered_lft;
+	__s32		regen_max_retry;
+	__s32		max_desync_factor;
+	__s32		max_addresses;
+	__s32		accept_ra_defrtr;
+	__s32		accept_ra_pinfo;
+#ifdef CONFIG_IPV6_ROUTER_PREF
+	__s32		accept_ra_rtr_pref;
+	__s32		rtr_probe_interval;
+#ifdef CONFIG_IPV6_ROUTE_INFO
+	__s32		accept_ra_rt_info_max_plen;
+#endif
+#endif
+	__s32		proxy_ndp;
+	__s32		accept_source_route;
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        __s32		ipv6_admin_enable;
+        __s32		ipv6_redirects;
+#endif
+
+#ifdef CONFIG_INET_LVL7_FP_UNREACHABLE_CTL
+        __s32		 ipv6_unreachables;
+#endif
+#ifdef CONFIG_IPV6_OPTIMISTIC_DAD
+	__s32		optimistic_dad;
+#endif
+#ifdef CONFIG_IPV6_MROUTE
+	__s32		mc_forwarding;
+#endif
+	__s32		disable_ipv6;
+	__s32		accept_dad;
+	__s32		force_tllao;
+	__s32           ndisc_notify;
+	__s32		suppress_frag_ndisc;
+	void		*sysctl;
+};
+
+struct ipv6_params {
+	__s32 disable_ipv6;
+	__s32 autoconf;
+};
+extern struct ipv6_params ipv6_defaults;
+#include <linux/icmpv6.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+
+#include <net/inet_sock.h>
+
+static inline struct ipv6hdr *ipv6_hdr(const struct sk_buff *skb)
+{
+	return (struct ipv6hdr *)skb_network_header(skb);
+}
+
+static inline struct ipv6hdr *inner_ipv6_hdr(const struct sk_buff *skb)
+{
+	return (struct ipv6hdr *)skb_inner_network_header(skb);
+}
+
+static inline struct ipv6hdr *ipipv6_hdr(const struct sk_buff *skb)
+{
+	return (struct ipv6hdr *)skb_transport_header(skb);
+}
+
+/* 
+   This structure contains results of exthdrs parsing
+   as offsets from skb->nh.
+ */
+
+struct inet6_skb_parm {
+	int			iif;
+	__be16			ra;
+	__u16			hop;
+	__u16			dst0;
+	__u16			srcrt;
+	__u16			dst1;
+	__u16			lastopt;
+	__u16			nhoff;
+	__u16			flags;
+#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
+	__u16			dsthao;
+#endif
+	__u16			frag_max_size;
+
+#define IP6SKB_XFRM_TRANSFORMED	1
+#define IP6SKB_FORWARDED	2
+#define IP6SKB_REROUTED		4
+#define IP6SKB_ROUTERALERT	8
+#define IP6SKB_FRAGMENTED      16
+};
+
+#define IP6CB(skb)	((struct inet6_skb_parm*)((skb)->cb))
+#define IP6CBMTU(skb)	((struct ip6_mtuinfo *)((skb)->cb))
+
+static inline int inet6_iif(const struct sk_buff *skb)
+{
+	return IP6CB(skb)->iif;
+}
+
+struct tcp6_request_sock {
+	struct tcp_request_sock	  tcp6rsk_tcp;
+};
+
+struct ipv6_mc_socklist;
+struct ipv6_ac_socklist;
+struct ipv6_fl_socklist;
+
+/**
+ * struct ipv6_pinfo - ipv6 private area
+ *
+ * In the struct sock hierarchy (tcp6_sock, upd6_sock, etc)
+ * this _must_ be the last member, so that inet6_sk_generic
+ * is able to calculate its offset from the base struct sock
+ * by using the struct proto->slab_obj_size member. -acme
+ */
+struct ipv6_pinfo {
+	struct in6_addr 	saddr;
+	struct in6_pktinfo	sticky_pktinfo;
+	const struct in6_addr		*daddr_cache;
+#ifdef CONFIG_IPV6_SUBTREES
+	const struct in6_addr		*saddr_cache;
+#endif
+
+	__be32			flow_label;
+	__u32			frag_size;
+
+	/*
+	 * Packed in 16bits.
+	 * Omit one shift by by putting the signed field at MSB.
+	 */
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__s16			hop_limit:9;
+	__u16			__unused_1:7;
+#else
+	__u16			__unused_1:7;
+	__s16			hop_limit:9;
+#endif
+
+#if defined(__BIG_ENDIAN_BITFIELD)
+	/* Packed in 16bits. */
+	__s16			mcast_hops:9;
+	__u16			__unused_2:6,
+				mc_loop:1;
+#else
+	__u16			mc_loop:1,
+				__unused_2:6;
+	__s16			mcast_hops:9;
+#endif
+	int			ucast_oif;
+	int			mcast_oif;
+
+	/* pktoption flags */
+	union {
+		struct {
+			__u16	srcrt:1,
+				osrcrt:1,
+			        rxinfo:1,
+			        rxoinfo:1,
+				rxhlim:1,
+				rxohlim:1,
+				hopopts:1,
+				ohopopts:1,
+				dstopts:1,
+				odstopts:1,
+                                rxflow:1,
+				rxtclass:1,
+				rxpmtu:1,
+				rxorigdstaddr:1;
+				/* 2 bits hole */
+		} bits;
+		__u16		all;
+	} rxopt;
+
+	/* sockopt flags */
+	__u16			recverr:1,
+	                        sndflow:1,
+				repflow:1,
+				pmtudisc:3,
+				ipv6only:1,
+				srcprefs:3,	/* 001: prefer temporary address
+						 * 010: prefer public address
+						 * 100: prefer care-of address
+						 */
+				dontfrag:1;
+	__u8			min_hopcount;
+	__u8			tclass;
+	__be32			rcv_flowinfo;
+
+	__u32			dst_cookie;
+	__u32			rx_dst_cookie;
+
+	struct ipv6_mc_socklist	__rcu *ipv6_mc_list;
+	struct ipv6_ac_socklist	*ipv6_ac_list;
+	struct ipv6_fl_socklist __rcu *ipv6_fl_list;
+
+	struct ipv6_txoptions	*opt;
+	struct sk_buff		*pktoptions;
+	struct sk_buff		*rxpmtu;
+	struct {
+		struct ipv6_txoptions *opt;
+		u8 hop_limit;
+		u8 tclass;
+	} cork;
+};
+
+/* WARNING: don't change the layout of the members in {raw,udp,tcp}6_sock! */
+struct raw6_sock {
+	/* inet_sock has to be the first member of raw6_sock */
+	struct inet_sock	inet;
+	__u32			checksum;	/* perform checksum */
+	__u32			offset;		/* checksum offset  */
+	struct icmp6_filter	filter;
+	__u32			ip6mr_table;
+	/* ipv6_pinfo has to be the last member of raw6_sock, see inet6_sk_generic */
+	struct ipv6_pinfo	inet6;
+};
+
+struct udp6_sock {
+	struct udp_sock	  udp;
+	/* ipv6_pinfo has to be the last member of udp6_sock, see inet6_sk_generic */
+	struct ipv6_pinfo inet6;
+};
+
+struct tcp6_sock {
+	struct tcp_sock	  tcp;
+	/* ipv6_pinfo has to be the last member of tcp6_sock, see inet6_sk_generic */
+	struct ipv6_pinfo inet6;
+};
+
+extern int inet6_sk_rebuild_header(struct sock *sk);
+
+struct tcp6_timewait_sock {
+	struct tcp_timewait_sock   tcp6tw_tcp;
+};
+
+#if IS_ENABLED(CONFIG_IPV6)
+static inline struct ipv6_pinfo * inet6_sk(const struct sock *__sk)
+{
+	return inet_sk(__sk)->pinet6;
+}
+
+static inline struct request_sock *inet6_reqsk_alloc(struct request_sock_ops *ops)
+{
+	struct request_sock *req = reqsk_alloc(ops);
+
+	if (req)
+		inet_rsk(req)->pktopts = NULL;
+
+	return req;
+}
+
+static inline struct raw6_sock *raw6_sk(const struct sock *sk)
+{
+	return (struct raw6_sock *)sk;
+}
+
+static inline void inet_sk_copy_descendant(struct sock *sk_to,
+					   const struct sock *sk_from)
+{
+	int ancestor_size = sizeof(struct inet_sock);
+
+	if (sk_from->sk_family == PF_INET6)
+		ancestor_size += sizeof(struct ipv6_pinfo);
+
+	__inet_sk_copy_descendant(sk_to, sk_from, ancestor_size);
+}
+
+#define __ipv6_only_sock(sk)	(inet6_sk(sk)->ipv6only)
+#define ipv6_only_sock(sk)	((sk)->sk_family == PF_INET6 && __ipv6_only_sock(sk))
+#define ipv6_sk_rxinfo(sk)	((sk)->sk_family == PF_INET6 && \
+				 inet6_sk(sk)->rxopt.bits.rxinfo)
+
+static inline const struct in6_addr *inet6_rcv_saddr(const struct sock *sk)
+{
+	if (sk->sk_family == AF_INET6)
+		return &sk->sk_v6_rcv_saddr;
+	return NULL;
+}
+
+static inline int inet_v6_ipv6only(const struct sock *sk)
+{
+	return likely(sk->sk_state != TCP_TIME_WAIT) ?
+		ipv6_only_sock(sk) : inet_twsk(sk)->tw_ipv6only;
+}
+#else
+#define __ipv6_only_sock(sk)	0
+#define ipv6_only_sock(sk)	0
+#define ipv6_sk_rxinfo(sk)	0
+
+static inline struct ipv6_pinfo * inet6_sk(const struct sock *__sk)
+{
+	return NULL;
+}
+
+static inline struct inet6_request_sock *
+			inet6_rsk(const struct request_sock *rsk)
+{
+	return NULL;
+}
+
+static inline struct raw6_sock *raw6_sk(const struct sock *sk)
+{
+	return NULL;
+}
+
+#define inet6_rcv_saddr(__sk)	NULL
+#define tcp_twsk_ipv6only(__sk)		0
+#define inet_v6_ipv6only(__sk)		0
+#endif /* IS_ENABLED(CONFIG_IPV6) */
+
+#define INET6_MATCH(__sk, __net, __saddr, __daddr, __ports, __dif)	\
+	(((__sk)->sk_portpair == (__ports))			&&	\
+	 ((__sk)->sk_family == AF_INET6)			&&	\
+	 ipv6_addr_equal(&(__sk)->sk_v6_daddr, (__saddr))		&&	\
+	 ipv6_addr_equal(&(__sk)->sk_v6_rcv_saddr, (__daddr))	&&	\
+	 (!(__sk)->sk_bound_dev_if	||				\
+	   ((__sk)->sk_bound_dev_if == (__dif))) 		&&	\
+	 net_eq(sock_net(__sk), (__net)))
+
+#endif /* _IPV6_H */
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/include/net/if_inet6.h linux-source-3.16.0.patch/include/net/if_inet6.h
--- linux-source-3.16.0/include/net/if_inet6.h	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/include/net/if_inet6.h	2016-08-11 19:33:34.441425094 -0400
@@ -198,6 +198,14 @@ struct inet6_dev {
 
 	struct in6_addr		token;
 
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        int                     ipv6_netdev_up;
+        int                     ipv6_enabled;
+#endif
+#ifdef CONFIG_IPV6_LVL7_MROUTE
+        unsigned short          mifi;
+#endif
+
 	struct neigh_parms	*nd_parms;
 	struct ipv6_devconf	cnf;
 	struct ipv6_devstat	stats;
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/include/net/neighbour.h linux-source-3.16.0.patch/include/net/neighbour.h
--- linux-source-3.16.0/include/net/neighbour.h	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/include/net/neighbour.h	2016-08-11 19:33:34.441425094 -0400
@@ -31,8 +31,15 @@
 /*
  * NUD stands for "neighbor unreachability detection"
  */
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+/* Limit the retransmit timeout of NS during exponential backoff NUD to be 60 secs
+ * as per draft-ietf-6man-impatient-nud-05.txt . */
+#define NEIGH_MAX_RETRANS_TIMER  (60 * HZ)  /* Max retransmission timer value: 60 secs */
 
+#define NUD_IN_TIMER   (NUD_INCOMPLETE|NUD_REACHABLE|NUD_DELAY|NUD_PROBE|NUD_UNREACHABLE)
+#else
 #define NUD_IN_TIMER	(NUD_INCOMPLETE|NUD_REACHABLE|NUD_DELAY|NUD_PROBE)
+#endif
 #define NUD_VALID	(NUD_PERMANENT|NUD_NOARP|NUD_REACHABLE|NUD_PROBE|NUD_STALE|NUD_DELAY)
 #define NUD_CONNECTED	(NUD_PERMANENT|NUD_NOARP|NUD_REACHABLE)
 
@@ -50,6 +57,10 @@ enum {
 	NEIGH_VAR_PROXY_QLEN,
 	NEIGH_VAR_ANYCAST_DELAY,
 	NEIGH_VAR_PROXY_DELAY,
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+	NEIGH_VAR_BACKOFF_MULTIPLE,
+	NEIGH_VAR_UNREACHEABLE,
+#endif
 	NEIGH_VAR_LOCKTIME,
 #define NEIGH_VAR_DATA_MAX (NEIGH_VAR_LOCKTIME + 1)
 	/* Following are used as a second way to access one of the above */
@@ -83,6 +94,10 @@ struct neigh_parms {
 	int	reachable_time;
 	int	data[NEIGH_VAR_DATA_MAX];
 	DECLARE_BITMAP(data_state, NEIGH_VAR_DATA_MAX);
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+       int     backoff_multiple;
+       int     mark_unreachable;
+#endif
 };
 
 static inline void neigh_var_set(struct neigh_parms *p, int index, int val)
@@ -144,7 +159,15 @@ struct neighbour {
 	unsigned long		used;
 	atomic_t		probes;
 	__u8			flags;
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+       /* To accomodate more space for any new flags in the future,
+        * expand the size of nud_state to short.
+        * UNREACHABLE state is introduced to implement exponential
+        * NUD as specified in draft-ietf-6man-impatient-nud-05.txt. */
+       unsigned short           nud_state;
+#else
 	__u8			nud_state;
+#endif
 	__u8			type;
 	__u8			dead;
 	seqlock_t		ha_lock;
@@ -238,6 +261,11 @@ static inline void *neighbour_priv(const
 #define NEIGH_UPDATE_F_OVERRIDE_ISROUTER	0x00000004
 #define NEIGH_UPDATE_F_ISROUTER			0x40000000
 #define NEIGH_UPDATE_F_ADMIN			0x80000000
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+/* Changes as per draft-ietf-6man-impatient-nud-05.txt.
+ * Flag to indicate if a neighbour entry is created due to redirect. */
+#define NEIGH_UPDATE_F_REDIRECT                 0x04000000
+#endif
 
 void neigh_table_init(struct neigh_table *tbl);
 int neigh_table_clear(struct neigh_table *tbl);
@@ -255,7 +283,12 @@ static inline struct neighbour *neigh_cr
 }
 void neigh_destroy(struct neighbour *neigh);
 int __neigh_event_send(struct neighbour *neigh, struct sk_buff *skb);
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+extern int                      neigh_update(struct neighbour *neigh, const u8 *lladdr, unsigned short new, 
+                                            u32 flags);
+#else
 int neigh_update(struct neighbour *neigh, const u8 *lladdr, u8 new, u32 flags);
+#endif
 void __neigh_set_probe_once(struct neighbour *neigh);
 void neigh_changeaddr(struct neigh_table *tbl, struct net_device *dev);
 int neigh_ifdown(struct neigh_table *tbl, struct net_device *dev);
@@ -368,7 +401,13 @@ static inline int neigh_event_send(struc
 	
 	if (neigh->used != now)
 		neigh->used = now;
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+       /* Use the existing link layer address for the neighbor even in UNREACHABLE
+        * state during communication to that neighbor. */
+        if (!(neigh->nud_state&(NUD_CONNECTED|NUD_DELAY|NUD_PROBE|NUD_UNREACHABLE)))
+#else
 	if (!(neigh->nud_state&(NUD_CONNECTED|NUD_DELAY|NUD_PROBE)))
+#endif
 		return __neigh_event_send(neigh, skb);
 	return 0;
 }
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/include/net/rawv6.h linux-source-3.16.0.patch/include/net/rawv6.h
--- linux-source-3.16.0/include/net/rawv6.h	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/include/net/rawv6.h	2016-08-11 19:33:34.441425094 -0400
@@ -16,4 +16,18 @@ int rawv6_mh_filter_unregister(int (*fil
 					     struct sk_buff *skb));
 #endif
 
+#ifdef CONFIG_IPV6_LVL7_MROUTE
+extern void rawv6_mroute_sock_deliver(struct sk_buff *skb);
+extern int rawv6_mroute_mifi_add(struct sock *sk, unsigned short mifi, unsigned short pifi);
+extern int rawv6_mroute_mifi_del(unsigned short mifi);
+extern int ravw6_mroute_pifi_del(unsigned short pifi);
+#define MRT6_BASE       200
+#define MRT6_INIT       (MRT6_BASE)     /* Enable the socket upon which this is called to 
+                                            send and receive multicast packets without 
+                                            regard to group membership */
+#define MRT6_DONE       (MRT6_BASE+1)   /* Cancel the above */
+#define MRT6_ADD_MIF    (MRT6_BASE+2)   /* Enable an interface's participation in the above */
+#define MRT6_DEL_MIF    (MRT6_BASE+3)   /* Disable an interface's participation in the above*/
+#endif
+
 #endif
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/include/uapi/linux/ip.h linux-source-3.16.0.patch/include/uapi/linux/ip.h
--- linux-source-3.16.0/include/uapi/linux/ip.h	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/include/uapi/linux/ip.h	2016-08-12 04:00:22.451933679 -0400
@@ -162,6 +162,9 @@ enum
 	IPV4_DEVCONF_SRC_VMARK,
 	IPV4_DEVCONF_PROXY_ARP_PVLAN,
 	IPV4_DEVCONF_ROUTE_LOCALNET,
+#ifdef CONFIG_INET_LVL7_FP_UNREACHABLE_CTL
+        IPV4_DEVCONF_SEND_UNREACHABLES,
+#endif
 	IPV4_DEVCONF_IGMPV2_UNSOLICITED_REPORT_INTERVAL,
 	IPV4_DEVCONF_IGMPV3_UNSOLICITED_REPORT_INTERVAL,
 	__IPV4_DEVCONF_MAX
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/include/uapi/linux/ipv6.h linux-source-3.16.0.patch/include/uapi/linux/ipv6.h
--- linux-source-3.16.0/include/uapi/linux/ipv6.h	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/include/uapi/linux/ipv6.h	2016-08-12 03:52:12.669316003 -0400
@@ -155,6 +155,13 @@ enum {
 	DEVCONF_PROXY_NDP,
 	DEVCONF_OPTIMISTIC_DAD,
 	DEVCONF_ACCEPT_SOURCE_ROUTE,
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        DEVCONFIG_IPV6_ADMIN_ENABLE,
+        DEVCONFIG_IPV6_REDIRECTS,
+#endif
+#ifdef CONFIG_INET_LVL7_FP_UNREACHABLE_CTL
+        DEVCONFIG_IPV6_UNREACHABLES,
+#endif
 	DEVCONF_MC_FORWARDING,
 	DEVCONF_DISABLE_IPV6,
 	DEVCONF_ACCEPT_DAD,
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/include/uapi/linux/neighbour.h linux-source-3.16.0.patch/include/uapi/linux/neighbour.h
--- linux-source-3.16.0/include/uapi/linux/neighbour.h	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/include/uapi/linux/neighbour.h	2016-08-11 19:33:34.441425094 -0400
@@ -40,6 +40,10 @@ enum {
 
 #define NTF_SELF	0x02
 #define NTF_MASTER	0x04
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+/* Implies this Neighbor is created on receiving an ICMPv6 REDIRECT packet. */
+#define NTF_REDIRECT    0x40
+#endif
 
 /*
  *	Neighbor Cache Entry States.
@@ -57,6 +61,11 @@ enum {
 #define NUD_PERMANENT	0x80
 #define NUD_NONE	0x00
 
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+/* Changes as per draft-ietf-6man-impatient-nud-05 draft. */
+#define NUD_UNREACHABLE 0x100
+#endif
+
 /* NUD_NOARP & NUD_PERMANENT are pseudostates, they never change
    and make no address resolution or NUD.
    NUD_PERMANENT also cannot be deleted by garbage collectors.
@@ -125,6 +134,10 @@ enum {
 	NDTPA_PROXY_QLEN,		/* u32 */
 	NDTPA_LOCKTIME,			/* u64, msecs */
 	NDTPA_QUEUE_LENBYTES,		/* u32 */
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        NDTPA_BACKOFF_MULTIPLE,         /* u32 */
+        NDTPA_MARK_UNREACHABLE,         /* u32 */
+#endif
 	__NDTPA_MAX
 };
 #define NDTPA_MAX (__NDTPA_MAX - 1)
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/include/uapi/linux/snmp.h linux-source-3.16.0.patch/include/uapi/linux/snmp.h
--- linux-source-3.16.0/include/uapi/linux/snmp.h	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/include/uapi/linux/snmp.h	2016-08-11 19:33:34.441425094 -0400
@@ -110,6 +110,13 @@ enum
 	ICMP6_MIB_OUTMSGS,			/* OutMsgs */
 	ICMP6_MIB_OUTERRORS,			/* OutErrors */
 	ICMP6_MIB_CSUMERRORS,			/* InCsumErrors */
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        ICMP6_MIB_DADFAILS,   /* Not in the MIB but we need to know
+                                 when this happens */
+        ICMP6_MIB_OUTECHOS,   /* Linux doesn't normally count this but 
+                                 we need to know it */
+        ICMP6_MIB_OUTROUTERADVERTISEMENTS, /* Ditto */
+#endif
 	__ICMP6_MIB_MAX
 };
 
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/include/uapi/linux/sockios.h linux-source-3.16.0.patch/include/uapi/linux/sockios.h
--- linux-source-3.16.0/include/uapi/linux/sockios.h	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/include/uapi/linux/sockios.h	2016-08-11 19:33:34.441425094 -0400
@@ -90,6 +90,9 @@
 #define SIOCDARP	0x8953		/* delete ARP table entry	*/
 #define SIOCGARP	0x8954		/* get ARP table entry		*/
 #define SIOCSARP	0x8955		/* set ARP table entry		*/
+#ifdef CONFIG_INET_LVL7_FP_GRAT_ARP_CTL
+#define SIOCSGRATARP    0x8956          /* send gratuitous ARP          */
+#endif
 
 /* RARP cache control calls. */
 #define SIOCDRARP	0x8960		/* delete RARP table entry	*/
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/include/uapi/linux/sysctl.h linux-source-3.16.0.patch/include/uapi/linux/sysctl.h
--- linux-source-3.16.0/include/uapi/linux/sysctl.h	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/include/uapi/linux/sysctl.h	2016-08-11 21:30:00.785108753 -0400
@@ -481,6 +481,9 @@ enum
 	NET_IPV4_CONF_PROMOTE_SECONDARIES=20,
 	NET_IPV4_CONF_ARP_ACCEPT=21,
 	NET_IPV4_CONF_ARP_NOTIFY=22,
+#ifdef CONFIG_INET_LVL7_FP_UNREACHABLE_CTL
+        NET_IPV4_CONF_SEND_UNREACHABLES=23,
+#endif
 };
 
 /* /proc/sys/net/ipv4/netfilter */
@@ -568,6 +571,12 @@ enum {
 	NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN=22,
 	NET_IPV6_PROXY_NDP=23,
 	NET_IPV6_ACCEPT_SOURCE_ROUTE=25,
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        NET_IPV6_ENABLE=26,
+#endif
+#ifdef CONFIG_INET_LVL7_FP_UNREACHABLE_CTL
+        NET_IPV6_UNREACHABLES=27,
+#endif
 	__NET_IPV6_MAX
 };
 
@@ -596,6 +605,10 @@ enum {
 	NET_NEIGH_GC_THRESH3=16,
 	NET_NEIGH_RETRANS_TIME_MS=17,
 	NET_NEIGH_REACHABLE_TIME_MS=18,
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        NET_NEIGH_BACKOFF_MULTIPLE=19,
+        NET_NEIGH_MARK_UNREACHABLE=20,
+#endif
 };
 
 /* /proc/sys/net/dccp */
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/kernel/sysctl_binary.c linux-source-3.16.0.patch/kernel/sysctl_binary.c
--- linux-source-3.16.0/kernel/sysctl_binary.c	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/kernel/sysctl_binary.c	2016-08-11 19:33:34.441425094 -0400
@@ -281,6 +281,10 @@ static const struct bin_table bin_net_ne
 	{ CTL_INT,	NET_NEIGH_GC_THRESH3,		"gc_thresh3" },
 	{ CTL_INT,	NET_NEIGH_RETRANS_TIME_MS,	"retrans_time_ms" },
 	{ CTL_INT,	NET_NEIGH_REACHABLE_TIME_MS,	"base_reachable_time_ms" },
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        { CTL_INT,      NET_NEIGH_BACKOFF_MULTIPLE,     "backoff_multiple" },
+        { CTL_INT,      NET_NEIGH_MARK_UNREACHABLE,     "mark_unreachable" },
+#endif
 	{}
 };
 
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/net/core/neighbour.c linux-source-3.16.0.patch/net/core/neighbour.c
--- linux-source-3.16.0/net/core/neighbour.c	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/net/core/neighbour.c	2016-08-11 19:33:34.445427044 -0400
@@ -40,6 +40,9 @@
 #include <linux/log2.h>
 #include <linux/inetdevice.h>
 #include <net/addrconf.h>
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+#include <linux/if_arp.h>
+#endif
 
 #define DEBUG
 #define NEIGH_DEBUG 1
@@ -145,8 +148,21 @@ static int neigh_forced_gc(struct neigh_
 			 * - it is not permanent
 			 */
 			write_lock(&n->lock);
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+                        if ((atomic_read(&n->refcnt) == 1) &&
+                            /* Garbage collect only those entries in
+                             * failed state. Don't disturb the stale entries
+                             * as they might be actively used in the hardware
+                             * and their maintenance is taken care of by the application.
+                             * Also, flush neighbor entries corresponding to link-local
+                             * solicited node multicast addresses.  */
+                            ((n->nud_state & NUD_FAILED) ||
+                             ((tbl->key_len == sizeof(struct in6_addr)) &&
+                              (n->primary_key[0] == 0xff) && (n->primary_key[1] == 0x02)))) {
+#else
 			if (atomic_read(&n->refcnt) == 1 &&
 			    !(n->nud_state & NUD_PERMANENT)) {
+#endif
 				rcu_assign_pointer(*np,
 					rcu_dereference_protected(n->next,
 						  lockdep_is_held(&tbl->lock)));
@@ -469,6 +485,59 @@ struct neighbour *__neigh_create(struct
 	struct neighbour *n1, *rc, *n = neigh_alloc(tbl, dev);
 	struct neigh_hash_table *nht;
 
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        /* If neigh_alloc() failed, one of the reasons could be that
+         * gc_thresh3 threshold for Neighbour table is reached and no
+         * entries could be cleaned to create space for new NCE.
+         *
+         * In that case, treat an exception here where we allow NCEs
+         * to be always created for link-local multicast destination
+         * addresses (like ff02::1 etc...) even if the Neighbor table
+         * is full, since these entries are not added in hardware and
+         * are temporarily created and garbage collected. Allow such
+         * entries to be always created to allow application layer L3
+         * protocols that use link-local multicast addresses to run
+         * smoothly. */
+        if (!n) {
+          if ((atomic_read(&tbl->entries) >= tbl->gc_thresh3) &&
+              (tbl->key_len == sizeof(struct in6_addr)) &&
+              (((u8 *)pkey)[0] == 0xff) && (((u8 *)pkey)[1] == 0x02)) {
+            atomic_inc(&tbl->entries);
+
+            if (tbl->entry_size)
+                  n = kzalloc(tbl->entry_size, GFP_ATOMIC);
+            else {
+                  int sz = sizeof(*n) + tbl->key_len;
+  
+                  sz = ALIGN(sz, NEIGH_PRIV_ALIGN);
+                  sz += dev->neigh_priv_len;
+                  n = kzalloc(sz, GFP_ATOMIC);
+            }
+
+            if (n) {
+              skb_queue_head_init(&n->arp_queue);
+              rwlock_init(&n->lock);
+              seqlock_init(&n->ha_lock);
+              n->updated          = n->used = jiffies;
+              n->nud_state        = NUD_NONE;
+              n->output           = neigh_blackhole;
+              seqlock_init(&n->hh.hh_lock);
+              n->parms            = neigh_parms_clone(&tbl->parms);
+              setup_timer(&n->timer, neigh_timer_handler, (unsigned long)n);
+
+              NEIGH_CACHE_STAT_INC(tbl, allocs);
+              n->tbl              = tbl;
+              atomic_set(&n->refcnt, 1);
+              n->dead             = 1;
+            }
+            else
+            {
+              atomic_dec(&tbl->entries);
+            }
+          }
+        }
+#endif
+
 	if (!n) {
 		rc = ERR_PTR(-ENOBUFS);
 		goto out;
@@ -538,6 +607,11 @@ struct neighbour *__neigh_create(struct
 	write_unlock_bh(&tbl->lock);
 	neigh_dbg(2, "neigh %p is created\n", n);
 	rc = n;
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        if (dev->type == ARPHRD_SIT) {
+          neigh_update_notify(n);
+        }
+#endif
 out:
 	return rc;
 out_tbl_unlock:
@@ -701,6 +775,14 @@ void neigh_destroy(struct neighbour *nei
 
 	NEIGH_CACHE_STAT_INC(neigh->tbl, destroys);
 
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        if(neigh->ops && (neigh->ops->family == AF_INET6)){
+          if(neigh->nud_state != NUD_FAILED)
+            neigh->nud_state = NUD_INCOMPLETE;
+          neigh_update_notify(neigh);
+        }
+#endif
+
 	if (!neigh->dead) {
 		pr_warn("Destroying alive neighbour %p\n", neigh);
 		dump_stack();
@@ -837,6 +919,12 @@ static __inline__ int neigh_max_probes(s
 {
 	struct neigh_parms *p = n->parms;
 	int max_probes = NEIGH_VAR(p, UCAST_PROBES) + NEIGH_VAR(p, APP_PROBES);
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+       if(n->ops->family == AF_INET6) {
+               return (NEIGH_VAR(p, UCAST_PROBES) + NEIGH_VAR(p, APP_PROBES) + NEIGH_VAR(p, MCAST_PROBES));
+       }
+#endif
+
 	if (!(n->nud_state & NUD_PROBE))
 		max_probes += NEIGH_VAR(p, MCAST_PROBES);
 	return max_probes;
@@ -866,6 +954,29 @@ static void neigh_invalidate(struct neig
 	__skb_queue_purge(&neigh->arp_queue);
 	neigh->arp_queue_len_bytes = 0;
 }
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+/* Return the next timeout value as per exponential backoff
+ * algorithm in draft-ietf-6man-impatient-nud-05.*/
+static int neigh_nud_next_timeout(int backoff,
+                                 int probe_count,
+                                 int retrans_time)
+{
+       int           i;
+       unsigned long timeout = 1;
+
+       for (i=1; i<= probe_count; i++) {
+               timeout = timeout * backoff;
+               if ((timeout * retrans_time) >= NEIGH_MAX_RETRANS_TIMER) {
+                       return NEIGH_MAX_RETRANS_TIMER;
+               }
+       }
+       return (timeout * retrans_time);
+}
+#endif
+
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+static  int neigh_probe_notify = 0, nud_timer_set = 0;;
+#endif
 
 static void neigh_probe(struct neighbour *neigh)
 	__releases(neigh->lock)
@@ -877,6 +988,28 @@ static void neigh_probe(struct neighbour
 	write_unlock(&neigh->lock);
 	neigh->ops->solicit(neigh, skb);
 	atomic_inc(&neigh->probes);
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+               /* Mark the NCE as UNREACHABLE after 'mark_unreachable' number
+                * of SOLICITs were sent in PROBE state. */
+               if (neigh->ops && (neigh->ops->family == AF_INET6) && (neigh->nud_state & NUD_PROBE)) {
+                       if (atomic_read(&neigh->probes) == neigh->parms->mark_unreachable) {
+                               neigh->nud_state = NUD_UNREACHABLE;
+                               neigh->updated = jiffies;
+                               neigh_probe_notify = 1;
+
+                               /* If the neighbor entry was formed due to REDIRECT packet,
+                               * delete it on transitioning to UNREACHABLE state. */
+                               if (neigh->flags & NTF_REDIRECT) {
+                                       neigh->nud_state = NUD_FAILED;
+                                       neigh_probe_notify = 1;
+                                       neigh_invalidate(neigh);
+                                       if (nud_timer_set == 1) {
+                                               neigh_release(neigh);
+                                       }
+                               }
+                       }
+               }
+#endif
 	kfree_skb(skb);
 }
 
@@ -888,6 +1021,9 @@ static void neigh_timer_handler(unsigned
 	struct neighbour *neigh = (struct neighbour *)arg;
 	unsigned int state;
 	int notify = 0;
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        nud_timer_set = 0;
+#endif
 
 	write_lock(&neigh->lock);
 
@@ -911,6 +1047,10 @@ static void neigh_timer_handler(unsigned
 			neigh->updated = jiffies;
 			neigh_suspect(neigh);
 			next = now + NEIGH_VAR(neigh->parms, DELAY_PROBE_TIME);
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+                        if (neigh->ops && (neigh->ops->family == AF_INET6))
+                               notify = 1;
+#endif
 		} else {
 			neigh_dbg(2, "neigh %p is suspected\n", neigh);
 			neigh->nud_state = NUD_STALE;
@@ -933,15 +1073,51 @@ static void neigh_timer_handler(unsigned
 			neigh->nud_state = NUD_PROBE;
 			neigh->updated = jiffies;
 			atomic_set(&neigh->probes, 0);
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+                        if (neigh->ops && (neigh->ops->family == AF_INET6)) {
+                               notify = 1;
+
+                               /* Get the next timeout using exponential backoff algorithm. */
+                               next = now + neigh_nud_next_timeout(neigh->parms->backoff_multiple,
+                                                                   (atomic_read(&neigh->probes)),
+                                                                   NEIGH_VAR(neigh->parms, RETRANS_TIME));
+                        } else {
+		               next = now + NEIGH_VAR(neigh->parms, RETRANS_TIME);
+                        }
+#else
+		        next = now + NEIGH_VAR(neigh->parms, RETRANS_TIME);
+#endif
+		}
+	} else {
+		/* NUD_PROBE|NUD_INCOMPLETE */
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+               if (neigh->ops && (neigh->ops->family == AF_INET6)) {
+                       if (state & (NUD_PROBE | NUD_UNREACHABLE)) {
+                               /* NUD_PROBE|NUD_UNREACHABLE */
+
+                               /* Get the next timeout using exponential backoff algorithm. */
+                               next = now + neigh_nud_next_timeout(neigh->parms->backoff_multiple,
+                                                                   (atomic_read(&neigh->probes)),
+                                                                   NEIGH_VAR(neigh->parms, RETRANS_TIME));
+                       } else {
+                               /* NUD_INCOMPLETE */
 			next = now + NEIGH_VAR(neigh->parms, RETRANS_TIME);
 		}
 	} else {
 		/* NUD_PROBE|NUD_INCOMPLETE */
 		next = now + NEIGH_VAR(neigh->parms, RETRANS_TIME);
 	}
-
+#else
+		next = now + NEIGH_VAR(neigh->parms, RETRANS_TIME);
+#endif
+	}
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        if ((neigh->nud_state & (NUD_INCOMPLETE | NUD_PROBE | NUD_UNREACHABLE)) &&
+            atomic_read(&neigh->probes) >= neigh_max_probes(neigh)) {
+#else
 	if ((neigh->nud_state & (NUD_INCOMPLETE | NUD_PROBE)) &&
 	    atomic_read(&neigh->probes) >= neigh_max_probes(neigh)) {
+#endif
 		neigh->nud_state = NUD_FAILED;
 		notify = 1;
 		neigh_invalidate(neigh);
@@ -951,11 +1127,27 @@ static void neigh_timer_handler(unsigned
 	if (neigh->nud_state & NUD_IN_TIMER) {
 		if (time_before(next, jiffies + HZ/2))
 			next = jiffies + HZ/2;
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+                if (!mod_timer(&neigh->timer, next)) {
+                        /* Set a flag to check later below when we delete an NCE
+                         * (created from redirect) transitioning to UNREACHABLE state. */
+                        nud_timer_set = 1;
+                        neigh_hold(neigh);
+                }
+#else
 		if (!mod_timer(&neigh->timer, next))
 			neigh_hold(neigh);
+#endif
 	}
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+       if (neigh->nud_state & (NUD_INCOMPLETE | NUD_PROBE | NUD_UNREACHABLE)) {
+               neigh_probe_notify  = notify;
+               neigh_probe(neigh);
+               notify = neigh_probe_notify;
+#else
 	if (neigh->nud_state & (NUD_INCOMPLETE | NUD_PROBE)) {
 		neigh_probe(neigh);
+#endif
 	} else {
 out:
 		write_unlock(&neigh->lock);
@@ -971,11 +1163,18 @@ int __neigh_event_send(struct neighbour
 {
 	int rc;
 	bool immediate_probe = false;
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        int neigh_notify = 0;
+#endif
 
 	write_lock_bh(&neigh->lock);
 
 	rc = 0;
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        if (neigh->nud_state & (NUD_CONNECTED | NUD_DELAY | NUD_PROBE | NUD_UNREACHABLE))
+#else
 	if (neigh->nud_state & (NUD_CONNECTED | NUD_DELAY | NUD_PROBE))
+#endif
 		goto out_unlock_bh;
 
 	if (!(neigh->nud_state & (NUD_STALE | NUD_INCOMPLETE))) {
@@ -991,6 +1190,10 @@ int __neigh_event_send(struct neighbour
 					 HZ/2);
 			neigh_add_timer(neigh, next);
 			immediate_probe = true;
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+                        /* Neighbor just transitioned to INCOMPLETE state. */
+                        neigh_notify = 1;
+#endif
 		} else {
 			neigh->nud_state = NUD_FAILED;
 			neigh->updated = jiffies;
@@ -1005,6 +1208,10 @@ int __neigh_event_send(struct neighbour
 		neigh->updated = jiffies;
 		neigh_add_timer(neigh, jiffies +
 				NEIGH_VAR(neigh->parms, DELAY_PROBE_TIME));
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+                /* Neighbor just transitioned to DELAY state. */
+                neigh_notify = 1;
+#endif
 	}
 
 	if (neigh->nud_state == NUD_INCOMPLETE) {
@@ -1032,6 +1239,13 @@ out_unlock_bh:
 	else
 		write_unlock(&neigh->lock);
 	local_bh_enable();
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        /* Report the INCOMPLETE neighbour state event to the upper layers
+         * to add any negative neighbour entries to the hardware. */
+        if (neigh_notify && neigh->ops && (neigh->ops->family == AF_INET6)) {
+               neigh_update_notify(neigh);
+        }
+#endif
 	return rc;
 }
 EXPORT_SYMBOL(__neigh_event_send);
@@ -1077,9 +1291,13 @@ static void neigh_update_hhs(struct neig
 
    Caller MUST hold reference count on the entry.
  */
-
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+int neigh_update(struct neighbour *neigh, const u8 *lladdr, unsigned short new,
+                u32 flags)
+#else
 int neigh_update(struct neighbour *neigh, const u8 *lladdr, u8 new,
 		 u32 flags)
+#endif
 {
 	u8 old;
 	int err;
@@ -1104,8 +1322,13 @@ int neigh_update(struct neighbour *neigh
 		neigh->nud_state = new;
 		err = 0;
 		notify = old & NUD_VALID;
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+                if ((old & (NUD_INCOMPLETE | NUD_PROBE | NUD_UNREACHABLE)) &&
+                    (new & NUD_FAILED)) {
+#else
 		if ((old & (NUD_INCOMPLETE | NUD_PROBE)) &&
 		    (new & NUD_FAILED)) {
+#endif
 			neigh_invalidate(neigh);
 			notify = 1;
 		}
@@ -1139,6 +1362,13 @@ int neigh_update(struct neighbour *neigh
 		neigh->confirmed = jiffies;
 	neigh->updated = jiffies;
 
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        if ((neigh->ops && neigh->ops->family == AF_INET6) &&
+           ((!(old & NUD_CONNECTED) && (new & NUD_CONNECTED)) ||
+            ((old & NUD_CONNECTED) && !(new & NUD_CONNECTED))))
+               notify = 1;
+#endif
+
 	/* If entry was valid and address is not changed,
 	   do not change entry state, if new one is STALE.
 	 */
@@ -1231,10 +1461,26 @@ out:
 			(neigh->flags | NTF_ROUTER) :
 			(neigh->flags & ~NTF_ROUTER);
 	}
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        /* Store a flag in the neighbour entry to say if this entry
+         * is created by a redirect packet. */
+        if (flags & NEIGH_UPDATE_F_REDIRECT) {
+               neigh->flags |= NTF_REDIRECT;
+        } else {
+               neigh->flags &= ~NTF_REDIRECT;
+        }
+#endif
+
 	write_unlock_bh(&neigh->lock);
 
+#ifndef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
 	if (notify)
 		neigh_update_notify(neigh);
+#else
+        if (notify && (NEIGH_VAR(neigh->parms, APP_PROBES) ||
+                       (neigh->ops && neigh->ops->family == AF_INET6)))
+          neigh_update_notify(neigh);
+#endif
 
 	return err;
 }
@@ -1982,6 +2228,10 @@ static const struct nla_policy nl_ntbl_p
 	[NDTPA_ANYCAST_DELAY]		= { .type = NLA_U64 },
 	[NDTPA_PROXY_DELAY]		= { .type = NLA_U64 },
 	[NDTPA_LOCKTIME]		= { .type = NLA_U64 },
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        [NDTPA_BACKOFF_MULTIPLE]        = { .type = NLA_U32 },
+        [NDTPA_MARK_UNREACHABLE]        = { .type = NLA_U32 },
+#endif
 };
 
 static int neightbl_set(struct sk_buff *skb, struct nlmsghdr *nlh)
@@ -2100,6 +2350,14 @@ static int neightbl_set(struct sk_buff *
 				NEIGH_VAR_SET(p, LOCKTIME,
 					      nla_get_msecs(tbp[i]));
 				break;
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+                        case NDTPA_BACKOFF_MULTIPLE:
+                                p->backoff_multiple = nla_get_u32(tbp[i]);
+                                break;
+                        case NDTPA_MARK_UNREACHABLE:
+                                p->mark_unreachable = nla_get_u32(tbp[i]);
+                                break;
+#endif
 			}
 		}
 	}
@@ -2206,7 +2464,11 @@ static int neigh_fill_info(struct sk_buf
 
 	read_lock_bh(&neigh->lock);
 	ndm->ndm_state	 = neigh->nud_state;
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+       if ((neigh->nud_state & (NUD_VALID | NUD_UNREACHABLE))) {
+#else
 	if (neigh->nud_state & NUD_VALID) {
+#endif
 		char haddr[MAX_ADDR_LEN];
 
 		neigh_ha_snapshot(haddr, neigh, neigh->dev);
@@ -2218,7 +2480,11 @@ static int neigh_fill_info(struct sk_buf
 
 	ci.ndm_used	 = jiffies_to_clock_t(now - neigh->used);
 	ci.ndm_confirmed = jiffies_to_clock_t(now - neigh->confirmed);
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
 	ci.ndm_updated	 = jiffies_to_clock_t(now - neigh->updated);
+#else
+	ci.ndm_updated	 = jiffies_to_clock_t(now - neigh->updated);
+#endif
 	ci.ndm_refcnt	 = atomic_read(&neigh->refcnt) - 1;
 	read_unlock_bh(&neigh->lock);
 
@@ -3000,6 +3266,20 @@ static struct neigh_sysctl_table {
 		NEIGH_SYSCTL_UNRES_QLEN_REUSED_ENTRY(QUEUE_LEN, QUEUE_LEN_BYTES, "unres_qlen"),
 		NEIGH_SYSCTL_MS_JIFFIES_REUSED_ENTRY(RETRANS_TIME_MS, RETRANS_TIME, "retrans_time_ms"),
 		NEIGH_SYSCTL_MS_JIFFIES_REUSED_ENTRY(BASE_REACHABLE_TIME_MS, BASE_REACHABLE_TIME, "base_reachable_time_ms"),
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+                [NEIGH_VAR_BACKOFF_MULTIPLE] = {
+                        .procname       = "backoff_multiple",
+                        .maxlen         = sizeof(int),
+                        .mode           = 0644,
+                        .proc_handler   = proc_dointvec,
+                },
+                [NEIGH_VAR_UNREACHEABLE] = {
+                        .procname       = "mark_unreachable",
+                        .maxlen         = sizeof(int),
+                        .mode           = 0644,
+                        .proc_handler   = proc_dointvec,
+                },
+#endif
 		[NEIGH_VAR_GC_INTERVAL] = {
 			.procname	= "gc_interval",
 			.maxlen		= sizeof(int),
@@ -3053,6 +3333,11 @@ int neigh_sysctl_register(struct net_dev
 		t->neigh_vars[i].extra2 = p;
 	}
 
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+       t->neigh_vars[NEIGH_VAR_BACKOFF_MULTIPLE].data  = &p->backoff_multiple;
+       t->neigh_vars[NEIGH_VAR_UNREACHEABLE].data  = &p->mark_unreachable;
+#endif
+
 	if (dev) {
 		dev_name_source = dev->name;
 		/* Terminate the table early */
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/net/ipv4/af_inet.c linux-source-3.16.0.patch/net/ipv4/af_inet.c
--- linux-source-3.16.0/net/ipv4/af_inet.c	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/net/ipv4/af_inet.c	2016-08-11 19:33:34.445427044 -0400
@@ -859,6 +859,9 @@ int inet_ioctl(struct socket *sock, unsi
 	case SIOCDARP:
 	case SIOCGARP:
 	case SIOCSARP:
+#ifdef CONFIG_INET_LVL7_FP_GRAT_ARP_CTL
+        case SIOCSGRATARP:
+#endif
 		err = arp_ioctl(net, cmd, (void __user *)arg);
 		break;
 	case SIOCGIFADDR:
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/net/ipv4/arp.c linux-source-3.16.0.patch/net/ipv4/arp.c
--- linux-source-3.16.0/net/ipv4/arp.c	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/net/ipv4/arp.c	2016-08-11 19:33:34.445427044 -0400
@@ -117,6 +117,18 @@
 #include <linux/uaccess.h>
 
 #include <linux/netfilter_arp.h>
+#ifdef CONFIG_INET_LVL7_FP_GRAT_ARP_CTL
+#define IP_ADDR_CONFLICT_NOTIFY_PORT 49160 /* UDP port for sending address conflicting
+                                            * encapsulated ARP frames to application */ 
+#define IP_ADDR_CONFLICT_NOTIFY_PAYLOAD_LEN (sizeof(struct arphdr) + 2 *(ETH_ALEN+4))
+struct addr_conflict_s {
+  char                 arp_data[IP_ADDR_CONFLICT_NOTIFY_PAYLOAD_LEN];
+  struct work_struct   work;
+};
+
+struct workqueue_struct *addr_conflict_wq = NULL;
+void addr_conflict_handler(struct work_struct *work);
+#endif
 
 /*
  *	Interface to generic neighbour cache.
@@ -715,6 +727,40 @@ void arp_send(int type, int ptype, __be3
 }
 EXPORT_SYMBOL(arp_send);
 
+#ifdef CONFIG_INET_LVL7_FP_GRAT_ARP_CTL
+/*
+ *	Send address conflict message to listeners.
+ */
+void addr_conflict_handler(struct work_struct *work) {
+   struct addr_conflict_s *ac = container_of(work, struct addr_conflict_s, work);
+   struct sockaddr_in    to;
+   struct socket         *sock;
+   struct msghdr         msg;
+   struct kvec           iov;
+
+   int retval = sock_create(PF_INET, SOCK_DGRAM, 0, &sock);
+   if (retval >= 0) {
+       memset(&to, 0, sizeof(to));
+       to.sin_family      = AF_INET;
+       to.sin_port        = htons(IP_ADDR_CONFLICT_NOTIFY_PORT);
+       to.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+
+       iov.iov_base    = (void *)ac->arp_data;
+       iov.iov_len     = IP_ADDR_CONFLICT_NOTIFY_PAYLOAD_LEN;
+       msg.msg_name    = (void *)&to;
+       msg.msg_namelen = sizeof(to);
+       msg.msg_control  = NULL;
+       msg.msg_controllen = 0;
+       msg.msg_flags    = MSG_DONTWAIT | MSG_NOSIGNAL;
+
+       kernel_sendmsg(sock, &msg, &iov, 1, iov.iov_len);
+       sock_release(sock);
+   }
+   /* Free created work */
+   kfree(ac);
+}
+#endif
+
 /*
  *	Process an arp request.
  */
@@ -832,6 +878,25 @@ static int arp_process(struct sk_buff *s
  *  cache.
  */
 
+#ifdef CONFIG_INET_LVL7_FP_GRAT_ARP_CTL
+        /* Report the address conflict error to the user if the sender IP
+         * in the ARP REQ or REPLY is matching the interface IP. */
+        if (addr_conflict_wq != NULL) {
+           if (inet_addr_type(net, sip) == RTN_LOCAL) {
+              struct addr_conflict_s *addr_conflict = NULL;
+
+              addr_conflict = kmalloc(sizeof(struct addr_conflict_s), GFP_ATOMIC);
+              if (addr_conflict != NULL) {
+                INIT_WORK(&addr_conflict->work, addr_conflict_handler);
+                memcpy(addr_conflict->arp_data, (void *)arp, IP_ADDR_CONFLICT_NOTIFY_PAYLOAD_LEN);
+                /* queue work to a handler */
+                if (!queue_work(addr_conflict_wq, &addr_conflict->work))
+                  kfree(addr_conflict);
+              }
+           }
+        }
+#endif
+
 	/* Special case: IPv4 duplicate address detection packet (RFC2131) */
 	if (sip == 0) {
 		if (arp->ar_op == htons(ARPOP_REQUEST) &&
@@ -1169,6 +1234,64 @@ static int arp_req_delete(struct net *ne
 	return arp_invalidate(dev, ip);
 }
 
+#ifdef CONFIG_INET_LVL7_FP_GRAT_ARP_CTL
+static int arp_send_grat_arp(struct net_device *dev)
+{
+    struct in_device *in_dev;
+    struct in_ifaddr **ifap = NULL;
+    struct in_ifaddr *ifa = NULL;
+
+    if ((in_dev = __in_dev_get_rtnl(dev)) != NULL) {
+        for (ifap = &in_dev->ifa_list; (ifa = *ifap) != NULL;
+                                       ifap = &ifa->ifa_next) {
+          /* sending gratuitous arp for each active ip address
+           * on this device */
+          arp_send(ARPOP_REQUEST, ETH_P_ARP, ifa->ifa_local, dev,
+                   ifa->ifa_local, NULL, dev->dev_addr, NULL);
+        }
+    }
+    return 0;
+}
+
+/*
+ *      Handle an ARP layer I/O control request.
+ */
+int arp_priv_ioctl(struct net *net, unsigned int cmd, void __user *arg)
+{
+        int err;
+        struct arpreq r;
+        struct net_device *dev = NULL;
+
+        switch (cmd) {
+                case SIOCSGRATARP:
+                /* Send gratuitous ARP packets for addresses on this interface */
+                        err = copy_from_user(&r, arg, sizeof(struct arpreq));
+                        if (err)
+                                return -EFAULT;
+                        break;
+                default:
+                        return -EINVAL;
+        }
+
+        if (r.arp_pa.sa_family != AF_INET)
+                return -EPFNOSUPPORT;
+
+        rtnl_lock();
+        err = -ENODEV;
+        if ((dev = __dev_get_by_name(net, r.arp_dev)) == NULL)
+                goto out;
+
+        switch(cmd) {
+        case SIOCSGRATARP:
+                err = arp_send_grat_arp(dev);
+                break;
+        }
+out:
+        rtnl_unlock();
+        return err;
+}
+#endif
+
 /*
  *	Handle an ARP layer I/O control request.
  */
@@ -1189,6 +1312,10 @@ int arp_ioctl(struct net *net, unsigned
 		if (err)
 			return -EFAULT;
 		break;
+#ifdef CONFIG_INET_LVL7_FP_GRAT_ARP_CTL
+        case SIOCSGRATARP:
+                return arp_priv_ioctl(net, cmd, arg);
+#endif
 	default:
 		return -EINVAL;
 	}
@@ -1296,6 +1423,15 @@ void __init arp_init(void)
 	neigh_sysctl_register(NULL, &arp_tbl.parms, NULL);
 #endif
 	register_netdevice_notifier(&arp_netdev_notifier);
+#ifdef CONFIG_INET_LVL7_FP_GRAT_ARP_CTL
+        if (!addr_conflict_wq) {
+           addr_conflict_wq = alloc_workqueue("ip_addr_conflict", 
+                                              WQ_MEM_RECLAIM | WQ_UNBOUND, 1);
+           if (!addr_conflict_wq) {
+              pr_debug("Failed to allocate ip address conflict workqueue\n");
+           }
+        }
+#endif
 }
 
 #ifdef CONFIG_PROC_FS
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/net/ipv4/devinet.c linux-source-3.16.0.patch/net/ipv4/devinet.c
--- linux-source-3.16.0/net/ipv4/devinet.c	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/net/ipv4/devinet.c	2016-08-12 03:43:27.077252288 -0400
@@ -75,6 +75,9 @@ static struct ipv4_devconf ipv4_devconf
 		[IPV4_DEVCONF_SHARED_MEDIA - 1] = 1,
 		[IPV4_DEVCONF_IGMPV2_UNSOLICITED_REPORT_INTERVAL - 1] = 10000 /*ms*/,
 		[IPV4_DEVCONF_IGMPV3_UNSOLICITED_REPORT_INTERVAL - 1] =  1000 /*ms*/,
+#ifdef CONFIG_INET_LVL7_FP_UNREACHABLE_CTL
+                [IPV4_DEVCONF_SEND_UNREACHABLES - 1] = 1,
+#endif
 	},
 };
 
@@ -87,6 +90,9 @@ static struct ipv4_devconf ipv4_devconf_
 		[IPV4_DEVCONF_ACCEPT_SOURCE_ROUTE - 1] = 1,
 		[IPV4_DEVCONF_IGMPV2_UNSOLICITED_REPORT_INTERVAL - 1] = 10000 /*ms*/,
 		[IPV4_DEVCONF_IGMPV3_UNSOLICITED_REPORT_INTERVAL - 1] =  1000 /*ms*/,
+#ifdef CONFIG_INET_LVL7_FP_UNREACHABLE_CTL
+                [IPV4_DEVCONF_SEND_UNREACHABLES - 1] = 1,
+#endif
 	},
 };
 
@@ -468,6 +474,13 @@ static int __inet_insert_ifa(struct in_i
 	ifa->ifa_next = *ifap;
 	*ifap = ifa;
 
+#ifdef CONFIG_INET_LVL7_FP_GRAT_ARP_CTL
+        /* Send gratuitous ARP for this IP address
+         * on this interface */
+        arp_send(ARPOP_REQUEST, ETH_P_ARP, ifa->ifa_local, in_dev->dev,
+                 ifa->ifa_local, NULL, in_dev->dev->dev_addr, NULL);
+#endif
+
 	inet_hash_insert(dev_net(in_dev->dev), ifa);
 
 	cancel_delayed_work(&check_lifetime_work);
@@ -2135,6 +2148,10 @@ static struct devinet_sysctl_table {
 					      "promote_secondaries"),
 		DEVINET_SYSCTL_FLUSHING_ENTRY(ROUTE_LOCALNET,
 					      "route_localnet"),
+#ifdef CONFIG_INET_LVL7_FP_UNREACHABLE_CTL
+                DEVINET_SYSCTL_RW_ENTRY(SEND_UNREACHABLES,
+                                              "ip_unreachables"),
+#endif
 	},
 };
 
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/net/ipv4/fib_frontend.c linux-source-3.16.0.patch/net/ipv4/fib_frontend.c
--- linux-source-3.16.0/net/ipv4/fib_frontend.c	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/net/ipv4/fib_frontend.c	2016-08-11 19:33:34.445427044 -0400
@@ -247,6 +247,9 @@ static int __fib_validate_source(struct
 	struct fib_result res;
 	struct flowi4 fl4;
 	struct net *net;
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        struct in_ifaddr *ifa;
+#endif
 	bool dev_match;
 
 	fl4.flowi4_oif = 0;
@@ -264,6 +267,21 @@ static int __fib_validate_source(struct
 	net = dev_net(dev);
 	if (fib_lookup(net, &fl4, &res))
 		goto last_resort;
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        if (res.type != RTN_UNICAST) {
+                /* If the source address belongs to a /31 attached subnet
+                 * on this interface, check if the address matches the broadcast
+                 * address in /31 subnet. There are 2 valid unicast addresses in
+                 * /31 subnet (one with 0 and one with 1 bit-value in 32nd bit).
+                 * Hence treat it also as an unicast address. */
+                for (ifa = idev->ifa_list; ifa; ifa = ifa->ifa_next) {
+                        if ((ifa->ifa_prefixlen == 31) && (src == htonl(ifa->ifa_broadcast))) {
+                                res.type = RTN_UNICAST;
+                                break;
+                        }
+                }
+        }
+#endif
 	if (res.type != RTN_UNICAST) {
 		if (res.type != RTN_LOCAL || !accept_local)
 			goto e_inval;
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/net/ipv4/icmp.c linux-source-3.16.0.patch/net/ipv4/icmp.c
--- linux-source-3.16.0/net/ipv4/icmp.c	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/net/ipv4/icmp.c	2016-08-12 03:43:52.265523787 -0400
@@ -491,6 +491,10 @@ void icmp_send(struct sk_buff *skb_in, i
 	int room;
 	struct icmp_bxm *icmp_param;
 	struct rtable *rt = skb_rtable(skb_in);
+#ifdef CONFIG_INET_LVL7_FP_UNREACHABLE_CTL
+        struct net_device *dev = skb_in->dev;
+        struct in_device *in_dev;
+#endif
 	struct ipcm_cookie ipc;
 	struct flowi4 fl4;
 	__be32 saddr;
@@ -501,6 +505,20 @@ void icmp_send(struct sk_buff *skb_in, i
 
 	if (!rt)
 		goto out;
+#ifdef CONFIG_INET_LVL7_FP_UNREACHABLE_CTL
+        if (type == ICMP_DEST_UNREACH) {
+          in_dev = in_dev_get(dev);
+
+         if (in_dev) {
+            if (!IN_DEV_CONF_GET(in_dev,SEND_UNREACHABLES))
+              {
+                in_dev_put(in_dev);
+                return;
+              }
+            in_dev_put(in_dev);
+          }
+        }
+#endif
 	net = dev_net(rt->dst.dev);
 
 	/*
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/net/ipv6/addrconf.c linux-source-3.16.0.patch/net/ipv6/addrconf.c
--- linux-source-3.16.0/net/ipv6/addrconf.c	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/net/ipv6/addrconf.c	2016-08-12 03:50:24.604667881 -0400
@@ -90,6 +90,9 @@
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 #include <linux/export.h>
+#ifdef CONFIG_IPV6_LVL7_MROUTE
+#include <net/rawv6.h>
+#endif
 
 /* Set to 3 to get tracing... */
 #define ACONF_DEBUG 2
@@ -196,6 +199,15 @@ static struct ipv6_devconf ipv6_devconf
 #endif
 	.proxy_ndp		= 0,
 	.accept_source_route	= 0,	/* we do not accept RH0 by default. */
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+/* Interfaces are disabled for v6 by default, so non-v6-capable packages 
+   don't need to mess with any of this at all */
+        .ipv6_admin_enable  = 0,
+        .ipv6_redirects     = 1,
+#endif
+#ifdef CONFIG_INET_LVL7_FP_UNREACHABLE_CTL
+        .ipv6_unreachables = 1,
+#endif
 	.disable_ipv6		= 0,
 	.accept_dad		= 1,
 	.suppress_frag_ndisc	= 1,
@@ -232,6 +244,15 @@ static struct ipv6_devconf ipv6_devconf_
 #endif
 	.proxy_ndp		= 0,
 	.accept_source_route	= 0,	/* we do not accept RH0 by default. */
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+/* Interfaces are disabled for v6 by default, so non-v6-capable packages 
+   don't need to mess with any of this at all */
+        .ipv6_admin_enable  = 0,
+        .ipv6_redirects     = 1,
+#endif
+#ifdef CONFIG_INET_LVL7_FP_UNREACHABLE_CTL
+        .ipv6_unreachables = 1,
+#endif
 	.disable_ipv6		= 0,
 	.accept_dad		= 1,
 	.suppress_frag_ndisc	= 1,
@@ -387,8 +408,14 @@ static struct inet6_dev *ipv6_add_dev(st
 
 	ndev->token = in6addr_any;
 
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        if (netif_running(dev) && netif_carrier_ok(dev) && ndev->ipv6_enabled) {
+                ndev->if_flags |= IF_READY;
+        }
+#else
 	if (netif_running(dev) && addrconf_qdisc_ok(dev))
 		ndev->if_flags |= IF_READY;
+#endif
 
 	ipv6_mc_init_dev(ndev);
 	ndev->tstamp = jiffies;
@@ -406,6 +433,9 @@ static struct inet6_dev *ipv6_add_dev(st
 	if (ndev->cnf.forwarding && (dev->flags & IFF_MULTICAST))
 		ipv6_dev_mc_inc(dev, &in6addr_linklocal_allrouters);
 
+#ifdef CONFIG_IPV6_LVL7_MROUTE
+        ndev->mifi = -1;
+#endif
 	return ndev;
 }
 
@@ -811,6 +841,13 @@ ipv6_add_addr(struct inet6_dev *idev, co
 		goto out2;
 	}
 
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+    if (!idev->ipv6_enabled) {
+        err = -EPERM;
+        goto out2;
+    }
+#endif
+
 	if (idev->cnf.disable_ipv6) {
 		err = -EACCES;
 		goto out2;
@@ -1645,6 +1682,10 @@ static int addrconf_dad_end(struct inet6
 
 void addrconf_dad_failure(struct inet6_ifaddr *ifp)
 {
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        ICMP6_INC_STATS(dev_net(ifp->idev->dev), ifp->idev, ICMP6_MIB_DADFAILS);
+        addrconf_dad_stop(ifp, 1);
+#else
 	struct inet6_dev *idev = ifp->idev;
 
 	if (addrconf_dad_end(ifp)) {
@@ -1677,6 +1718,7 @@ void addrconf_dad_failure(struct inet6_i
 	spin_unlock_bh(&ifp->state_lock);
 
 	addrconf_mod_dad_work(ifp, 0);
+#endif
 }
 
 /* Join to solicited addr multicast group.
@@ -2448,6 +2490,11 @@ static int inet6_addr_add(struct net *ne
 	if (IS_ERR(idev))
 		return PTR_ERR(idev);
 
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        if (!idev->ipv6_enabled) {
+                return -EPERM;
+        }
+#endif
 	scope = ipv6_addr_scope(pfx);
 
 	timeout = addrconf_timeout_fixup(valid_lft, HZ);
@@ -2476,7 +2523,14 @@ static int inet6_addr_add(struct net *ne
 			addrconf_prefix_route(&ifp->addr, ifp->prefix_len, dev,
 					      expires, flags);
 		}
-
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+                /* IF_READY might have been cleared by deleting the last 
+                   address, but we can't necessarily count on a 
+                   NETDEV_UP/CHANGE after here to kick things... */
+                if (netif_running(dev) && netif_carrier_ok(dev)) {
+                  idev->if_flags |= IF_READY;
+                }
+#endif
 		/*
 		 * Note that section 3.1 of RFC 4429 indicates
 		 * that the Optimistic flag should not be set for
@@ -2600,6 +2654,13 @@ static void sit_add_v4_addrs(struct inet
 	memset(&addr, 0, sizeof(struct in6_addr));
 	memcpy(&addr.s6_addr32[3], idev->dev->dev_addr, 4);
 
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS      
+        /* to allow setting of link-local address on 6to4 tunnels 
+         * as well that are not point-to-point */
+        addr.s6_addr32[0] = htonl(0xfe800000);
+        scope = IFA_LINK;
+		plen = 128;
+#else
 	if (idev->dev->flags&IFF_POINTOPOINT) {
 		addr.s6_addr32[0] = htonl(0xfe800000);
 		scope = IFA_LINK;
@@ -2609,6 +2670,7 @@ static void sit_add_v4_addrs(struct inet
 		plen = 96;
 		pflags |= RTF_NONEXTHOP;
 	}
+#endif
 
 	if (addr.s6_addr32[3]) {
 		add_addr(idev, &addr, plen, scope);
@@ -2659,6 +2721,9 @@ static void init_loopback(struct net_dev
 		pr_debug("%s: add_dev failed\n", __func__);
 		return;
 	}
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        idev->ipv6_enabled = 1;
+#endif
 
 	add_addr(idev, &in6addr_loopback, 128, IFA_HOST);
 
@@ -2826,15 +2891,48 @@ static int addrconf_notify(struct notifi
 		break;
 
 	case NETDEV_UP:
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS      
+          /* Set ipv6_enable flag as configured */
+          if (!idev) {
+            /* Create the idev... this will allow sysctls against it */
+            idev = ipv6_add_dev(dev);
+          }
+          if (idev) {
+            idev->ipv6_netdev_up = 1;
+            if( idev->cnf.ipv6_admin_enable) {
+              idev->ipv6_enabled = 1;
+            }
+          }
+#endif
 	case NETDEV_CHANGE:
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+          /* Handle changes in ipv6_enable */
+          if (idev) {
+            if (idev->cnf.ipv6_admin_enable && (!(idev->ipv6_enabled))) {
+              if (idev->ipv6_netdev_up) {
+                idev->ipv6_enabled = 1;
+              }
+            }
+           if ((!(idev->cnf.ipv6_admin_enable)) && idev->ipv6_enabled) {
+              addrconf_ifdown(idev->dev, 0);
+              idev->ipv6_enabled = 0;
+            }
+            /* Nothing more to do if IPv6 has been disabled */
+            if (!(idev->ipv6_enabled)) {
+              break;
+            }
+          }
+#endif
 		if (dev->flags & IFF_SLAVE)
 			break;
 
 		if (event == NETDEV_UP) {
 			if (!addrconf_qdisc_ok(dev)) {
 				/* device is not ready yet. */
+#ifndef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
 				pr_info("ADDRCONF(NETDEV_UP): %s: link is not ready\n",
 					dev->name);
+#endif
 				break;
 			}
 
@@ -2858,8 +2956,10 @@ static int addrconf_notify(struct notifi
 				idev->if_flags |= IF_READY;
 			}
 
+#ifndef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
 			pr_info("ADDRCONF(NETDEV_CHANGE): %s: link becomes ready\n",
 				dev->name);
+#endif
 
 			run_pending = 1;
 		}
@@ -2927,13 +3027,25 @@ static int addrconf_notify(struct notifi
 		 * if MTU under IPV6_MIN_MTU.
 		 * Stop IPv6 on this interface.
 		 */
-
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+                if (!idev && dev->mtu >= IPV6_MIN_MTU) {
+                  idev = ipv6_add_dev(dev);
+                  if (idev)
+                    break;
+                }
+#endif
 	case NETDEV_DOWN:
 	case NETDEV_UNREGISTER:
 		/*
 		 *	Remove all addresses from this interface.
 		 */
 		addrconf_ifdown(dev, event != NETDEV_DOWN);
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+                if (idev) {
+                  idev->ipv6_enabled = 0;
+                  idev->ipv6_netdev_up = 0;
+                }
+#endif
 		break;
 
 	case NETDEV_CHANGENAME:
@@ -4789,6 +4901,68 @@ int addrconf_sysctl_forward(struct ctl_t
 	return ret;
 }
 
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+/*
+ *
+ * Handler for /proc and sysctl objects that manage the 'ipv6_enabled'
+ * flag per-interface or in the default.
+ */
+static int
+addrconf_sysctl_ipv6_enable(ctl_table *ctl, int write,
+                            void *buf, size_t *lenp, loff_t *ppos)
+{
+        struct inet6_dev *idev = (struct inet6_dev *)ctl->extra1;
+        int ret;
+        int old_val, new_val;
+
+
+        if (idev) {
+            old_val = idev->cnf.ipv6_admin_enable;
+        }
+        ret = proc_dointvec(ctl, write, buf, lenp, ppos);
+        if (idev) {
+            new_val = idev->cnf.ipv6_admin_enable;
+        }
+        if (idev && write && (old_val != new_val)) {
+           /*
+            * Changing an individual device, make
+            * sure it has a chance to process the
+            * change.
+            */
+           rtnl_lock();
+           netdev_state_change(idev->dev);
+           rtnl_unlock();
+        }
+        return ret;
+}
+/*
+ *
+ * Handler for /proc and sysctl objects that manage the mtu.
+ * Modifies routes pointer to idev.
+ */
+static int
+addrconf_sysctl_mtu(ctl_table *ctl, int write, 
+                            void *buffer, size_t *lenp, loff_t *ppos)
+{
+        struct inet6_dev *idev = (struct inet6_dev *)ctl->extra1;
+        int *valp = ctl->data;
+        int old_val = *valp;
+        int new_val;
+        int ret;
+
+        ret = proc_dointvec(ctl, write, buffer, lenp, ppos);
+
+        if (idev && write && *valp != old_val) {
+                /* need to restore original val prior to changing routes */
+                new_val = idev->cnf.mtu6;
+                idev->cnf.mtu6 = old_val;
+                rt6_mtu_change(idev->dev,new_val);
+                idev->cnf.mtu6 = new_val;
+        }
+        return ret;
+}
+#endif
+
 static void dev_disable_change(struct inet6_dev *idev)
 {
 	struct netdev_notifier_info info;
@@ -4940,7 +5114,11 @@ static struct addrconf_sysctl_table
 			.data		= &ipv6_devconf.mtu6,
 			.maxlen		= sizeof(int),
 			.mode		= 0644,
+#ifndef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
 			.proc_handler	= proc_dointvec,
+#else
+                        .proc_handler   = addrconf_sysctl_mtu,
+#endif
 		},
 		{
 			.procname	= "accept_ra",
@@ -5163,6 +5341,31 @@ static struct addrconf_sysctl_table
 			.mode		= 0644,
 			.proc_handler	= proc_dointvec
 		},
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        {
+            .procname       =     "ipv6_enable",
+            .data           =     &ipv6_devconf.ipv6_admin_enable,
+            .maxlen         =     sizeof(int),
+            .mode           =     0644,
+            .proc_handler   =     addrconf_sysctl_ipv6_enable,
+        },
+        {
+            .procname       =     "ipv6_redirects",
+            .data           =     &ipv6_devconf.ipv6_redirects,
+            .maxlen         =     sizeof(int),
+            .mode           =     0644,
+            .proc_handler   =     proc_dointvec,
+        },
+#endif
+#ifdef CONFIG_INET_LVL7_FP_UNREACHABLE_CTL
+        {
+           .procname        =     "ipv6_unreachables",
+           .data            =     &ipv6_devconf.ipv6_unreachables,
+           .maxlen          =     sizeof(int),
+           .mode            =     0644,
+           .proc_handler    =     proc_dointvec,
+        },
+#endif
 		{
 			/* sentinel */
 		}
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/net/ipv6/addrconf_core.c linux-source-3.16.0.patch/net/ipv6/addrconf_core.c
--- linux-source-3.16.0/net/ipv6/addrconf_core.c	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/net/ipv6/addrconf_core.c	2016-08-11 19:33:34.453430943 -0400
@@ -7,6 +7,9 @@
 #include <net/ipv6.h>
 #include <net/addrconf.h>
 #include <net/ip.h>
+#ifdef CONFIG_IPV6_LVL7_MROUTE
+#include <net/rawv6.h>
+#endif
 
 /* if ipv6 module registers this function is used by xfrm to force all
  * sockets to relookup their nodes - this is fairly expensive, be
@@ -146,6 +149,9 @@ void in6_dev_finish_destroy(struct inet6
 #ifdef NET_REFCNT_DEBUG
 	pr_debug("%s: %s\n", __func__, dev ? dev->name : "NIL");
 #endif
+#ifdef CONFIG_IPV6_LVL7_MROUTE
+    rawv6_mroute_mifi_del(idev->mifi);
+#endif
 	dev_put(dev);
 	if (!idev->dead) {
 		pr_warn("Freeing alive inet6 device %p\n", idev);
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/net/ipv6/icmp.c linux-source-3.16.0.patch/net/ipv6/icmp.c
--- linux-source-3.16.0/net/ipv6/icmp.c	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/net/ipv6/icmp.c	2016-08-12 03:50:51.609824550 -0400
@@ -406,6 +406,19 @@ static void icmp6_send(struct sk_buff *s
 	    (skb_network_header(skb) + sizeof(*hdr)) > skb_tail_pointer(skb))
 		return;
 
+#ifdef CONFIG_INET_LVL7_FP_UNREACHABLE_CTL
+        if (type == ICMPV6_DEST_UNREACH) {
+          idev = in6_dev_get(skb->dev);
+          if (idev) {
+            if( !idev->cnf.ipv6_unreachables ) {
+              in6_dev_put(idev);
+              return;
+            }
+            in6_dev_put(idev);
+            idev = NULL;
+          }
+        }
+#endif
 	/*
 	 *	Make sure we respect the rules
 	 *	i.e. RFC 1885 2.4(e)
@@ -699,9 +712,11 @@ static int icmpv6_rcv(struct sk_buff *sk
 	daddr = &ipv6_hdr(skb)->daddr;
 
 	if (skb_checksum_validate(skb, IPPROTO_ICMPV6, ip6_compute_pseudo)) {
+#ifndef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
 		LIMIT_NETDEBUG(KERN_DEBUG
 			       "ICMPv6 checksum failed [%pI6c > %pI6c]\n",
 			       saddr, daddr);
+#endif
 		goto csum_error;
 	}
 
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/net/ipv6/ip6_input.c linux-source-3.16.0.patch/net/ipv6/ip6_input.c
--- linux-source-3.16.0/net/ipv6/ip6_input.c	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/net/ipv6/ip6_input.c	2016-08-11 19:33:34.453430943 -0400
@@ -78,6 +78,12 @@ int ipv6_rcv(struct sk_buff *skb, struct
 
 	idev = __in6_dev_get(skb->dev);
 
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        if (idev && !idev->ipv6_enabled) {
+          goto drop;
+        }
+#endif
+
 	IP6_UPD_PO_STATS_BH(net, idev, IPSTATS_MIB_IN, skb->len);
 
 	if ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL ||
@@ -290,6 +296,19 @@ int ip6_mc_input(struct sk_buff *skb)
 			 skb->len);
 
 	hdr = ipv6_hdr(skb);
+#ifdef CONFIG_IPV6_LVL7_MROUTE
+    if (ip6_dst_idev(skb_dst(skb)) && (ip6_dst_idev(skb_dst(skb))->mifi != -1)) {
+        rawv6_mroute_sock_deliver(skb);
+    }
+    if(hdr->nexthdr == NEXTHDR_HOP) {
+        skb->ip_summed = CHECKSUM_UNNECESSARY;
+        if(*(u8 *)(hdr+1) == IPPROTO_ICMPV6) {
+            /* MLD packet */
+            ip6_input(skb);
+            return 0;
+        }
+    }
+#endif
 	deliver = ipv6_chk_mcast_addr(skb->dev, &hdr->daddr, NULL);
 
 #ifdef CONFIG_IPV6_MROUTE
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/net/ipv6/ip6_output.c linux-source-3.16.0.patch/net/ipv6/ip6_output.c
--- linux-source-3.16.0/net/ipv6/ip6_output.c	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/net/ipv6/ip6_output.c	2016-08-11 19:33:34.453430943 -0400
@@ -64,6 +64,14 @@ static int ip6_finish_output2(struct sk_
 	struct in6_addr *nexthop;
 	int ret;
 
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        struct inet6_dev *idev = ip6_dst_idev(dst);
+        if (unlikely(idev && (!(idev->ipv6_enabled)))) {
+          kfree_skb(skb);
+          return -EPERM;
+        }
+#endif
+
 	skb->protocol = htons(ETH_P_IPV6);
 	skb->dev = dev;
 
@@ -368,8 +376,15 @@ int ip6_forward(struct sk_buff *skb)
 	struct net *net = dev_net(dst->dev);
 	u32 mtu;
 
+#ifndef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
 	if (net->ipv6.devconf_all->forwarding == 0)
 		goto error;
+#else
+        /* Check output interface to see if it has routing enabled */
+        if (ip6_dst_idev(dst)->cnf.forwarding == 0) {
+                goto error;
+        }
+#endif
 
 	if (skb->pkt_type != PACKET_HOST)
 		goto drop;
@@ -1589,6 +1604,11 @@ int ip6_push_pending_frames(struct sock
 
 		ICMP6MSGOUT_INC_STATS(net, idev, icmp6_hdr(skb)->icmp6_type);
 		ICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTMSGS);
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+                /* count outgoing echo requests. Can't count at the application
+                 * level because app doesn't know the outgoing interface. */
+                ICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTECHOS);
+#endif /* CONFIG_IPV6_LVL7_FP_INTEGRATIONS */
 	}
 
 	err = ip6_local_out(skb);
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/net/ipv6/ipv6_sockglue.c linux-source-3.16.0.patch/net/ipv6/ipv6_sockglue.c
--- linux-source-3.16.0/net/ipv6/ipv6_sockglue.c	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/net/ipv6/ipv6_sockglue.c	2016-08-11 19:33:34.453430943 -0400
@@ -62,8 +62,13 @@ int ip6_ra_control(struct sock *sk, int
 {
 	struct ip6_ra_chain *ra, *new_ra, **rap;
 
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        /* RA packet may be delivered ONLY to IPPROTO_RAW socket */
+        if (sk->sk_type != SOCK_RAW)
+#else
 	/* RA packet may be delivered ONLY to IPPROTO_RAW socket */
 	if (sk->sk_type != SOCK_RAW || inet_sk(sk)->inet_num != IPPROTO_RAW)
+#endif
 		return -ENOPROTOOPT;
 
 	new_ra = (sel>=0) ? kmalloc(sizeof(*new_ra), GFP_KERNEL) : NULL;
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/net/ipv6/Kconfig linux-source-3.16.0.patch/net/ipv6/Kconfig
--- linux-source-3.16.0/net/ipv6/Kconfig	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/net/ipv6/Kconfig	2016-08-11 19:33:34.453430943 -0400
@@ -230,6 +230,22 @@ config IPV6_SUBTREES
 
 	  If unsure, say N.
 
+config IPV6_LVL7_FP_INTEGRATIONS
+        bool "IPv6: Broadcom FASTPATH Integrations"
+        depends on IPV6 && IPV6_SUBTREES
+        ---help---
+          Changes to the IPv6 code to integrate with Broadcom FASTPATH
+          switch/router software. Say N unless building a kernel to
+          use with an IPv6-capable FASTPATH package.
+
+config IPV6_LVL7_MROUTE
+        bool "IPv6: Broadcom FASTPATH IPv6 Multicast Routing support"
+        depends on IPV6 && IPV6_LVL7_FP_INTEGRATIONS
+        ---help---
+          Changes to the IPv6 code to support Broadcom FASTPATH's
+          IPv6 multicast routing support. Say N unless building a kernel
+          to use with an IPv6 multicast routing-capable FASTPATH package.
+
 config IPV6_MROUTE
 	bool "IPv6: multicast routing"
 	depends on IPV6
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/net/ipv6/ndisc.c linux-source-3.16.0.patch/net/ipv6/ndisc.c
--- linux-source-3.16.0/net/ipv6/ndisc.c	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/net/ipv6/ndisc.c	2016-08-11 19:33:34.453430943 -0400
@@ -137,6 +137,10 @@ struct neigh_table nd_tbl = {
 			[NEIGH_VAR_PROXY_QLEN] = 64,
 			[NEIGH_VAR_ANYCAST_DELAY] = 1 * HZ,
 			[NEIGH_VAR_PROXY_DELAY] = (8 * HZ) / 10,
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+			[NEIGH_VAR_BACKOFF_MULTIPLE]  = 1,
+			[NEIGH_VAR_UNREACHEABLE] = 3,
+#endif
 		},
 	},
 	.gc_interval =	  30 * HZ,
@@ -377,8 +381,13 @@ static struct sk_buff *ndisc_alloc_skb(s
 
 	skb = alloc_skb(hlen + sizeof(struct ipv6hdr) + len + tlen, GFP_ATOMIC);
 	if (!skb) {
+#ifndef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
 		ND_PRINTK(0, err, "ndisc: %s failed to allocate an skb\n",
 			  __func__);
+#else
+		ND_PRINTK(0, notice, "ndisc: %s failed to allocate an skb\n",
+			  __func__);
+#endif
 		return NULL;
 	}
 
@@ -834,9 +843,22 @@ static void ndisc_recv_ns(struct sk_buff
 			     NEIGH_UPDATE_F_WEAK_OVERRIDE|
 			     NEIGH_UPDATE_F_OVERRIDE);
 	if (neigh || !dev->header_ops) {
+#ifndef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
 		ndisc_send_na(dev, neigh, saddr, &msg->target,
 			      !!is_router,
 			      true, (ifp != NULL && inc), inc);
+#else
+        if (neigh->nud_state & NUD_VALID) {
+            ndisc_send_na(dev, neigh, saddr, &msg->target,
+                      !!is_router,
+			          true, (ifp != NULL && inc), inc);
+        } else {
+            struct in6_addr mcaddr;
+
+            addrconf_addr_solict_mult(saddr, &mcaddr);
+            ndisc_send_ns(dev, NULL, saddr, &mcaddr, NULL);
+        }
+#endif
 		if (neigh)
 			neigh_release(neigh);
 	}
@@ -1423,6 +1445,19 @@ void ndisc_send_redirect(struct sk_buff
 	int rd_len;
 	u8 ha_buf[MAX_ADDR_LEN], *ha = NULL;
 	bool ret;
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        struct inet6_dev *idev;
+
+       idev = in6_dev_get(dev);
+       if (idev) {
+               if(!idev->cnf.ipv6_redirects) {
+                       in6_dev_put(idev);
+                       return;
+               }
+               in6_dev_put(idev);
+               idev = NULL;
+       }
+#endif
 
 	if (ipv6_get_lladdr(dev, &saddr_buf, IFA_F_TENTATIVE)) {
 		ND_PRINTK(2, warn, "Redirect: no link-local address on %s\n",
@@ -1705,6 +1740,10 @@ static int __net_init ndisc_net_init(str
 
 	np = inet6_sk(sk);
 	np->hop_limit = 255;
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        sk->sk_sndbuf = 128 * 1024; /* 128 KB. Enough buffer space to handle a
+                                     * burst of sending NS to 1K neighbors. */
+#endif
 	/* Do not loopback ndisc messages */
 	np->mc_loop = 0;
 
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/net/ipv6/proc.c linux-source-3.16.0.patch/net/ipv6/proc.c
--- linux-source-3.16.0/net/ipv6/proc.c	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/net/ipv6/proc.c	2016-08-11 19:33:34.453430943 -0400
@@ -105,6 +105,13 @@ static const struct snmp_mib snmp6_icmp6
 	SNMP_MIB_ITEM("Icmp6OutMsgs", ICMP6_MIB_OUTMSGS),
 	SNMP_MIB_ITEM("Icmp6OutErrors", ICMP6_MIB_OUTERRORS),
 	SNMP_MIB_ITEM("Icmp6InCsumErrors", ICMP6_MIB_CSUMERRORS),
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        SNMP_MIB_ITEM("Icmp6DadFails", ICMP6_MIB_DADFAILS), /* Not in the MIB but we need 
+                                                               to know when it happens */
+        SNMP_MIB_ITEM("Icmp6OutEchos", ICMP6_MIB_OUTECHOS), /* Linux doesn't normally count these
+                                                               but we need to know */
+        SNMP_MIB_ITEM("Icmp6OutRouterAdvertisements", ICMP6_MIB_OUTROUTERADVERTISEMENTS), /* Ditto */
+#endif
 	SNMP_MIB_SENTINEL
 };
 
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/net/ipv6/raw.c linux-source-3.16.0.patch/net/ipv6/raw.c
--- linux-source-3.16.0/net/ipv6/raw.c	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/net/ipv6/raw.c	2016-08-11 19:33:34.453430943 -0400
@@ -69,6 +69,17 @@ static struct raw_hashinfo raw_v6_hashin
 	.lock = __RW_LOCK_UNLOCKED(raw_v6_hashinfo.lock),
 };
 
+#ifdef CONFIG_IPV6_LVL7_MROUTE
+static struct sock *l7_v6_mcast_socket = NULL;
+DEFINE_SEMAPHORE(mifi_list_lock);
+LIST_HEAD(mifi_list);
+struct mifi_list_entry {
+    struct list_head list;
+    unsigned short mifi;
+    unsigned short pifi;
+};
+#endif
+
 static struct sock *__raw_v6_lookup(struct net *net, struct sock *sk,
 		unsigned short num, const struct in6_addr *loc_addr,
 		const struct in6_addr *rmt_addr, int dif)
@@ -126,6 +137,114 @@ static int icmpv6_filter(const struct so
 	return 1;
 }
 
+#ifdef CONFIG_IPV6_LVL7_MROUTE
+/* Deliver a copy of this packet to the special multicast socket, if any. */
+void rawv6_mroute_sock_deliver(struct sk_buff *skb)
+{
+    struct sk_buff *clone;
+    struct ipv6hdr *ipv6h;
+
+    ipv6h = ipv6_hdr(skb);
+
+    if ((l7_v6_mcast_socket == NULL) ||
+        (!ipv6_addr_is_multicast(&ipv6h->daddr))) {
+        return;
+    }
+
+    clone = skb_clone(skb, GFP_ATOMIC);
+    if (clone) {
+        nf_reset(clone);
+        rawv6_rcv(l7_v6_mcast_socket, clone);
+    }
+}
+/* Enable this interface for reception to the above socket. */
+int rawv6_mroute_mifi_add(struct sock *sk,
+                          unsigned short mifi,
+                          unsigned short pifi) {
+    struct net_device *dev;
+    struct inet6_dev *idev;
+    struct mifi_list_entry *cur_mifi;
+
+    if ((dev = dev_get_by_index(sock_net(sk), pifi)) == NULL) {
+        return -ENODEV;
+    }
+    if ((idev = in6_dev_get(dev)) == NULL) {
+        dev_put(dev);
+        return -EINVAL;
+    }
+    while (down_interruptible(&mifi_list_lock)) {
+        ; /* Do nothing until we have the lock */
+    }
+    list_for_each_entry(cur_mifi, &mifi_list, list) {
+        if ((cur_mifi->mifi == mifi) || (cur_mifi->pifi == pifi)) {
+            up(&mifi_list_lock);
+            in6_dev_put(idev);
+            dev_put(dev);
+            return -EINVAL;
+        }
+    }
+    cur_mifi = kmalloc(sizeof(struct mifi_list_entry), GFP_KERNEL);
+    if (cur_mifi == NULL) {
+        up(&mifi_list_lock);
+        in6_dev_put(idev);
+        dev_put(dev);
+        return -ENOMEM;
+    }
+    cur_mifi->mifi = mifi;
+    cur_mifi->pifi = pifi;
+    list_add(&cur_mifi->list, &mifi_list);
+    up(&mifi_list_lock);
+    idev->mifi = mifi;
+    in6_dev_put(idev);
+    dev_put(dev);
+    return 0;
+}
+/* Disable this interface for reception to the above socket. */
+int rawv6_mroute_mifi_del(unsigned short mifi) {
+    struct net_device *dev;
+    struct inet6_dev *idev;
+    struct mifi_list_entry *cur_mifi;
+    int ifindex = -1;
+
+    if(mifi == 0) return 0;
+
+    while (down_interruptible(&mifi_list_lock)) {
+            ; /* Do nothing until we have the lock */
+    }
+    list_for_each_entry(cur_mifi, &mifi_list, list) {
+        if (cur_mifi->mifi == mifi) {
+            ifindex = cur_mifi->pifi;
+            list_del(&cur_mifi->list);
+            kfree(cur_mifi);
+            up(&mifi_list_lock);
+            if ((dev = dev_get_by_index(&init_net, ifindex)) == NULL) {
+                return -EINVAL;
+            }
+            if ((idev = in6_dev_get(dev)) == NULL) {
+                dev_put(dev);
+                return -EINVAL;
+            }
+            idev->mifi = 0;
+            in6_dev_put(idev);
+            dev_put(dev);
+            return 0;
+        }
+    }
+    up(&mifi_list_lock);
+    return -ENODEV;
+}
+
+/* Delete all MIF entries, for when v6 mroute is globally disabled. */
+void rawv6_mroute_delete_all_mifs(void) {
+    struct mifi_list_entry *cur_mifi, *temp_mifi;
+
+    list_for_each_entry_safe(cur_mifi, temp_mifi, &mifi_list, list) {
+        rawv6_mroute_mifi_del(cur_mifi->mifi);
+    }
+
+}
+#endif
+
 #if IS_ENABLED(CONFIG_IPV6_MIP6)
 typedef int mh_filter_t(struct sock *sock, struct sk_buff *skb);
 
@@ -1012,6 +1131,63 @@ static int rawv6_setsockopt(struct sock
 	case SOL_IPV6:
 		if (optname == IPV6_CHECKSUM)
 			break;
+        #ifdef CONFIG_IPV6_LVL7_MROUTE
+            switch (optname) {
+                case MRT6_INIT:
+                    if (sk == l7_v6_mcast_socket) {
+                        return 0; /* idempotent */
+                    }
+                    if (l7_v6_mcast_socket) {
+                        return -EAGAIN;
+                    }
+                    l7_v6_mcast_socket = sk;
+                    return 0;
+                case MRT6_DONE:
+                    if (!l7_v6_mcast_socket) {
+                        return 0;
+                    }
+                    if (sk != l7_v6_mcast_socket) {
+                        return -EINVAL;
+                    }
+                    l7_v6_mcast_socket = NULL;
+                    rawv6_mroute_delete_all_mifs();
+                    return 0;
+             case MRT6_ADD_MIF:
+                {
+                    struct mif6ctl arg;
+
+                    if (l7_v6_mcast_socket == NULL) {
+                        return -EINVAL;
+                    }
+                    if (optlen != sizeof(arg)) {
+                        return -EINVAL;
+                    }
+                    if (copy_from_user(&arg, optval, sizeof(arg))) {
+                        return -EFAULT;
+                    }
+                    if (arg.mif6c_flags || arg.vifc_rate_limit || arg.vifc_threshold) {
+                        printk(KERN_WARNING "Process %d called MRT6_ADD_MIF setsockopt with unsupported arguments\n",
+                               current->pid);
+                    }
+                    return rawv6_mroute_mifi_add(sk, arg.mif6c_mifi, arg.mif6c_pifi);
+                }
+             case MRT6_DEL_MIF:
+                {
+                    unsigned short mifi;
+
+                    if (optlen != sizeof(unsigned short)) {
+                        return -EINVAL;
+                    }
+                    if (copy_from_user(&mifi, optval, sizeof(unsigned short))) {
+                        return -EFAULT;
+                    }
+                    if (l7_v6_mcast_socket == NULL) {
+                        return -EINVAL;
+                    }
+                    return rawv6_mroute_mifi_del(mifi);
+                }
+            }
+#endif
 	default:
 		return ipv6_setsockopt(sk, level, optname, optval, optlen);
 	}
@@ -1033,6 +1209,63 @@ static int compat_rawv6_setsockopt(struc
 	case SOL_IPV6:
 		if (optname == IPV6_CHECKSUM)
 			break;
+#ifdef CONFIG_IPV6_LVL7_MROUTE
+            switch (optname) {
+                case MRT6_INIT:
+                    if (sk == l7_v6_mcast_socket) {
+                        return 0; /* idempotent */
+                    }
+                    if (l7_v6_mcast_socket) {
+                        return -EAGAIN;
+                    }
+                    l7_v6_mcast_socket = sk;
+                    return 0;
+                case MRT6_DONE:
+                    if (!l7_v6_mcast_socket) {
+                        return 0;
+                    }
+                    if (sk != l7_v6_mcast_socket) {
+                        return -EINVAL;
+                    }
+                    l7_v6_mcast_socket = NULL;
+                    rawv6_mroute_delete_all_mifs();
+                    return 0;
+             case MRT6_ADD_MIF:
+                {
+                    struct mif6ctl arg;
+
+                    if (l7_v6_mcast_socket == NULL) {
+                        return -EINVAL;
+                    }
+                    if (optlen != sizeof(arg)) {
+                        return -EINVAL;
+                    }
+                    if (copy_from_user(&arg, optval, sizeof(arg))) {
+                        return -EFAULT;
+                    }
+                    if (arg.mif6c_flags || arg.vifc_rate_limit || arg.vifc_threshold) {
+                        printk(KERN_WARNING "Process %d called MRT6_ADD_MIF setsockopt with unsupported arguments\n",
+                               current->pid);
+                    }
+                    return rawv6_mroute_mifi_add(sk, arg.mif6c_mifi, arg.mif6c_pifi);
+                }
+             case MRT6_DEL_MIF:
+                {
+                    unsigned short mifi;
+
+                    if (optlen != sizeof(unsigned short)) {
+                        return -EINVAL;
+                    }
+                    if (copy_from_user(&mifi, optval, sizeof(unsigned short))) {
+                        return -EFAULT;
+                    }
+                    if (l7_v6_mcast_socket == NULL) {
+                        return -EINVAL;
+                    }
+                    return rawv6_mroute_mifi_del(mifi);
+                }
+            }
+#endif
 	default:
 		return compat_ipv6_setsockopt(sk, level, optname,
 					      optval, optlen);
@@ -1170,6 +1403,12 @@ static void rawv6_close(struct sock *sk,
 {
 	if (inet_sk(sk)->inet_num == IPPROTO_RAW)
 		ip6_ra_control(sk, -1);
+#ifdef CONFIG_IPV6_LVL7_MROUTE
+    if (sk == l7_v6_mcast_socket) {
+        l7_v6_mcast_socket = NULL;
+        rawv6_mroute_delete_all_mifs();
+    }
+#endif
 	ip6mr_sk_done(sk);
 	sk_common_release(sk);
 }
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/net/ipv6/route.c linux-source-3.16.0.patch/net/ipv6/route.c
--- linux-source-3.16.0/net/ipv6/route.c	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/net/ipv6/route.c	2016-08-11 19:33:34.453430943 -0400
@@ -104,6 +104,11 @@ static struct rt6_info *rt6_get_route_in
 					   const struct in6_addr *gwaddr, int ifindex);
 #endif
 
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+static int              ip6_pkt_reject(struct sk_buff *skb);
+static int              ip6_pkt_reject_out(struct sock *sk, struct sk_buff *skb);
+#endif
+
 static void rt6_bind_peer(struct rt6_info *rt, int create)
 {
 	struct inet_peer_base *base;
@@ -1485,6 +1490,11 @@ int ip6_route_add(struct fib6_config *cf
 		idev = in6_dev_get(dev);
 		if (!idev)
 			goto out;
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+                if (!idev->ipv6_enabled) {
+                     goto out;
+                }
+#endif
 	}
 
 	if (cfg->fc_metric == 0)
@@ -1588,6 +1598,15 @@ int ip6_route_add(struct fib6_config *cf
 			rt->dst.input = ip6_pkt_discard;
 			break;
 		}
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+                /* If the RTF_REJECT flag is set for this route,
+                 * assign the input/output functions specific to reject routes */
+                if (cfg->fc_flags & RTF_REJECT)
+                {
+                  rt->dst.output = ip6_pkt_reject_out;
+                  rt->dst.input = ip6_pkt_reject;
+                }
+#endif
 		goto install_route;
 	}
 
@@ -1829,6 +1848,10 @@ static void rt6_do_redirect(struct dst_e
 	neigh_update(neigh, lladdr, NUD_STALE,
 		     NEIGH_UPDATE_F_WEAK_OVERRIDE|
 		     NEIGH_UPDATE_F_OVERRIDE|
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+                     /* Flag to say this neighbor is created from a redirect packet. */
+                     NEIGH_UPDATE_F_REDIRECT|
+#endif
 		     (on_link ? 0 : (NEIGH_UPDATE_F_OVERRIDE_ISROUTER|
 				     NEIGH_UPDATE_F_ISROUTER))
 		     );
@@ -2130,6 +2153,26 @@ static int ip6_pkt_discard_out(struct so
 	return ip6_pkt_drop(skb, ICMPV6_NOROUTE, IPSTATS_MIB_OUTNOROUTES);
 }
 
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+/* RFC 4443: Section 3.1 -
+   If the reason for the failure to deliver is that the route to the
+   destination is a reject route, the Code field is set to 6.  This may
+   occur if the router has been configured to reject all the traffic for
+   a specific prefix.
+*/
+
+static int ip6_pkt_reject(struct sk_buff *skb)
+{
+        return ip6_pkt_drop(skb, ICMPV6_REJECT_ROUTE, IPSTATS_MIB_INNOROUTES);
+}
+
+static int ip6_pkt_reject_out(struct sock *sk, struct sk_buff *skb)
+{
+        skb->dev = skb_dst(skb)->dev;
+        return ip6_pkt_drop(skb, ICMPV6_REJECT_ROUTE, IPSTATS_MIB_OUTNOROUTES);
+}
+#endif
+
 static int ip6_pkt_prohibit(struct sk_buff *skb)
 {
 	return ip6_pkt_drop(skb, ICMPV6_ADM_PROHIBITED, IPSTATS_MIB_INNOROUTES);
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/net/ipv6/sit.c linux-source-3.16.0.patch/net/ipv6/sit.c
--- linux-source-3.16.0/net/ipv6/sit.c	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/net/ipv6/sit.c	2016-08-11 19:33:34.457432893 -0400
@@ -820,6 +820,9 @@ static netdev_tx_t ipip6_tunnel_xmit(str
 	int addr_type;
 	u8 ttl;
 	int err;
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        int sending_over_6to4_tunnel = 0;
+#endif
 
 	if (skb->protocol != htons(ETH_P_IPV6))
 		goto tx_error;
@@ -857,6 +860,21 @@ static netdev_tx_t ipip6_tunnel_xmit(str
 	if (!dst)
 		dst = try_6rd(tunnel, &iph6->daddr);
 
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        if (dst) {
+            sending_over_6to4_tunnel = 1;
+        }
+        /* RFC 3056: Section 9 - Security Considerations.
+         * ...any 6to4 traffic whose source or destination address
+         * embeds a V4ADDR which is not in the format of a global unicast
+         * address MUST be silently discarded by both encapsulators and
+         * decapsulators. */
+        if (dst  &&
+           ((dst == INADDR_BROADCAST) || ipv4_is_multicast(dst))) {
+           goto tx_error;
+        }
+#endif
+
 	if (!dst) {
 		struct neighbour *neigh = NULL;
 		bool do_tx_error = false;
@@ -876,6 +894,33 @@ static netdev_tx_t ipip6_tunnel_xmit(str
 			addr6 = &ipv6_hdr(skb)->daddr;
 			addr_type = ipv6_addr_type(addr6);
 		}
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+                if ((addr_type & IPV6_ADDR_COMPATv4) != 0) {
+                        dst = addr6->s6_addr32[3];
+                }
+                else {
+                        /* if nexthop neighbor is 6to4 router (in 2002::/16),
+                         * extract ipv4 dst from that 6to4 address */
+                        dst = try_6rd(tunnel, addr6);
+                        if (dst) {
+                           sending_over_6to4_tunnel = 1;
+                        }
+                        /* RFC 3056: Section 9 - Security Considerations.
+                         * ...any 6to4 traffic whose source or destination address
+                         * embeds a V4ADDR which is not in the format of a global unicast
+                         * address MUST be silently discarded by both encapsulators and
+                         * decapsulators. */
+                        if (dst  &&
+                            ((dst == INADDR_BROADCAST) || ipv4_is_multicast(dst))) {
+                           neigh_release(neigh);
+                           goto tx_error;
+                        }
+                }
+                neigh_release(neigh);
+                if (! dst) {
+                        goto tx_error;
+                }
+#else
 
 		if ((addr_type & IPV6_ADDR_COMPATv4) != 0)
 			dst = addr6->s6_addr32[3];
@@ -885,6 +930,7 @@ static netdev_tx_t ipip6_tunnel_xmit(str
 		neigh_release(neigh);
 		if (do_tx_error)
 			goto tx_error;
+#endif
 	}
 
 	rt = ip_route_output_ports(tunnel->net, &fl4, NULL,
@@ -973,6 +1019,14 @@ static netdev_tx_t ipip6_tunnel_xmit(str
 		goto out;
 	}
 
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        /* RFC 3056: Section 4 - Maximum Transmission Unit
+         * ...The IPv4 "do not fragment" bit SHOULD NOT be set in the
+         * encapsulating IPv4 header. */
+        if (sending_over_6to4_tunnel == 1)
+                  df = 0;
+#endif
+
 	err = iptunnel_xmit(skb->sk, rt, skb, fl4.saddr, fl4.daddr,
 			    IPPROTO_IPV6, tos, ttl, df,
 			    !net_eq(tunnel->net, dev_net(dev)));
@@ -1058,7 +1112,19 @@ static void ipip6_tunnel_bind_dev(struct
 
 	if (tdev) {
 		dev->hard_header_len = tdev->hard_header_len + sizeof(struct iphdr);
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+   /* RFC 4213, Section 3.2.1
+    * A node using static tunnel MTU treats the tunnel interface as having
+    * a fixed-interface MTU.  By default, the MTU MUST be between 1280 and
+    * 1480 bytes (inclusive), but it SHOULD be 1280 bytes.  If the default
+    * is not 1280 bytes, the implementation MUST have a configuration knob
+    * that can be used to change the MTU value.
+    * NOTE: We don't support the configuration of tunnel MTU currently */
+                dev->mtu = IPV6_MIN_MTU;
+#else
 		dev->mtu = tdev->mtu - sizeof(struct iphdr);
+#endif
+
 		if (dev->mtu < IPV6_MIN_MTU)
 			dev->mtu = IPV6_MIN_MTU;
 	}
@@ -1342,7 +1408,18 @@ static void ipip6_tunnel_setup(struct ne
 
 	dev->type		= ARPHRD_SIT;
 	dev->hard_header_len 	= LL_MAX_HEADER + sizeof(struct iphdr);
+#ifdef CONFIG_IPV6_LVL7_FP_INTEGRATIONS
+        /* RFC 4213, Section 3.2.1
+         * A node using static tunnel MTU treats the tunnel interface as having
+         * a fixed-interface MTU.  By default, the MTU MUST be between 1280 and
+         * 1480 bytes (inclusive), but it SHOULD be 1280 bytes.  If the default
+         * is not 1280 bytes, the implementation MUST have a configuration knob
+         * that can be used to change the MTU value.
+         * NOTE: We don't support the configuration of tunnel MTU currently */
+        dev->mtu                = IPV6_MIN_MTU;
+#else
 	dev->mtu		= ETH_DATA_LEN - sizeof(struct iphdr);
+#endif
 	dev->flags		= IFF_NOARP;
 	dev->priv_flags	       &= ~IFF_XMIT_DST_RELEASE;
 	dev->iflink		= 0;
diff -aburpwBNX /home/user/workspace/diff_exclude.txt linux-source-3.16.0/net/Kconfig linux-source-3.16.0.patch/net/Kconfig
--- linux-source-3.16.0/net/Kconfig	2015-05-12 04:34:49.000000000 -0400
+++ linux-source-3.16.0.patch/net/Kconfig	2016-08-12 03:48:17.730856104 -0400
@@ -82,6 +82,27 @@ source "net/netlabel/Kconfig"
 
 endif # if INET
 
+config INET_LVL7_FP_UNREACHABLE_CTL
+        bool "Broadcom FASTPATH: unreachables sysctls"
+        depends on INET
+        default N
+        ---help---
+          Add ip_unreachables and ipv6_unreachables to the per-
+          interface sysctls. If set to 0, they prevent ICMP Unreachable
+          packets from being sent by the kernel on those interfaces.
+          Say Y if building a kernel for use with Broadcom FASTPATH.
+
+config INET_LVL7_FP_GRAT_ARP_CTL
+        bool "Broadcom FASTPATH: control on sending and receiving grat arps"
+        depends on INET
+        default N
+        ---help---
+          This enables to control the reception and sending of gratuitous
+          ARP packets on an interface.
+          On reception of gratuitous ARP packets, the ip address conflict
+          is detected and reported to user using socket interface.
+          Say Y if building a kernel for use with Broadcom FASTPATH.
+
 config NETWORK_SECMARK
 	bool "Security Marking"
 	help
